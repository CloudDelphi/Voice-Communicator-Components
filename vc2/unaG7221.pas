(*

Copyright 2018 Alex Shamray

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*)


(*
	----------------------------------------------

	  unaG7221.pas - G.722.1 codec implementation
	  VC components version 2.5

	----------------------------------------------
	  Delphi conversion of original C code:

	  Copyright (c) 2011-2011 Lake of Soft
		     All rights reserved

	  http://lakeofsoft.com/
	----------------------------------------------

	  created by:
		Lake, Oct 2011

	  modified by:
		Lake, Oct 2011

	----------------------------------------------
*)

{$I unaDef.inc }

{$IFDEF DEBUG }
  //
  {$DEFINE LOG_G722_INFOS }	// log informational messages
  {$DEFINE LOG_G722_ERRORS }	// log critical errors
{$ENDIF DEBUG }

{*
  G.722.1 implementation based on ITU source code

  @Author Lake

  1.0 First release
}

unit
  unaG7221;

interface

uses
  unaTypes, unaClasses;

{*****************************************************************
******************************************************************
**
**   G.722.1 Annex B - G.722.1 Floating point implementation
**   > Software Release 2.1 (2008-06)
**
**	Filename : Huff_defs.h
**
**   © 2000 PictureTel Coporation
**          Andover, MA, USA
**
**	    All rights reserved.
**
******************************************************************
*****************************************************************}

const
  REGION_POWER_STEPSIZE_DB	= 3.010299957;
  ABS_REGION_POWER_LEVELS	= 32;
  DIFF_REGION_POWER_LEVELS	= 24;

  DRP_DIFF_MIN			= -12;
  DRP_DIFF_MAX			= 11;

  NUM_CATEGORIES		= 8;
  MAX_NUM_BINS			= 14;
  MAX_VECTOR_INDICES		= 625;
  MAX_VECTOR_DIMENSION		= 5;

{*****************************************************************
******************************************************************
**
**   G.722.1 Annex B - G.722.1 Floating point implementation
**   > Software Release 2.1 (2008-06)
**
**	Filename : defs.h
**
**   © 2000 PictureTel Coporation
**          Andover, MA, USA
**
**	    All rights reserved.
**
******************************************************************
*****************************************************************}

const
  PI			= 3.141592653589793238462;

  MAX_DCT_SIZE 		= 640;

//#define MAX(a,b) (a > b ? a : b)
//#define MIN(a,b) (a < b ? a : b)

  MAX_NUM_REGIONS 	= 28;

  NUM_REGIONS		= 14;

  REGION_POWER_TABLE_SIZE		= 64;
  REGION_POWER_TABLE_NUM_NEGATIVES	= 24;

  MAX_NUM_RATE_CONTROL_BITS		= 5;
  MAX_NUM_RATE_CONTROL_POSSIBILITIES	= 32;

  ENCODER_SCALE_FACTOR			= 18318.0;

{* The MLT output is incorrectly scaled by the factor
   product of ENCODER_SCALE_FACTOR and sqrt(160.)
   This is now (9/30/96) 1.0/2^(4.5) or 1/22.627.
   In the current implementation this product
   must be an integer power of sqrt(2). The
   integer power is ESF_ADJUSTMENT_TO_RMS_INDEX.
   The -2 is to conform with the range defined in the spec. *}

{*
** This value has been changed for fixed point interop
*}
  ESF_ADJUSTMENT_TO_RMS_INDEX	= (9-2); // changed from (-2)

  INTERMEDIATE_FILES_FLAG 	= 0;

//* Max bit rate is now 48000 bits/sec. */

  MAX_BITS_PER_FRAME 	= 960;




{*****************************************************************
******************************************************************
**
**   G.722.1 Annex B - G.722.1 Floating point implementation
**   > Software Release 2.1 (2008-06)
**
**	Filename : huff_tables.h
**
**   © 2000 PictureTel Coporation
**          Andover, MA, USA
**
**	    All rights reserved.
**
******************************************************************
*****************************************************************}

const
  differential_region_power_bits: array[0..MAX_NUM_REGIONS - 1, 0..DIFF_REGION_POWER_LEVELS - 1] of int32 = (
(  99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99),
(   4, 6, 5, 5, 4, 4, 4, 4, 4, 4, 3, 3, 3, 4, 5, 7, 8, 9,11,11,12,12,12,12),
(  10, 8, 6, 5, 5, 4, 3, 3, 3, 3, 3, 3, 4, 5, 7, 9,11,12,13,15,15,15,16,16),
(  12,10, 8, 6, 5, 4, 4, 4, 4, 4, 4, 3, 3, 3, 4, 4, 5, 5, 7, 9,11,13,14,14),
(  13,10, 9, 9, 7, 7, 5, 5, 4, 3, 3, 3, 3, 3, 4, 4, 4, 5, 7, 9,11,13,13,13),
(  12,13,10, 8, 6, 6, 5, 5, 4, 4, 3, 3, 3, 3, 3, 4, 5, 5, 6, 7, 9,11,14,14),
(  12,11, 9, 8, 8, 7, 5, 4, 4, 3, 3, 3, 3, 3, 4, 4, 5, 5, 7, 8,10,13,14,14),
(  15,16,15,12,10, 8, 6, 5, 4, 3, 3, 3, 2, 3, 4, 5, 5, 7, 9,11,13,16,16,16),
(  14,14,11,10, 9, 7, 7, 5, 5, 4, 3, 3, 2, 3, 3, 4, 5, 7, 9, 9,12,14,15,15),
(   9, 9, 9, 8, 7, 6, 5, 4, 3, 3, 3, 3, 3, 3, 4, 5, 6, 7, 8,10,11,12,13,13),
(  14,12,10, 8, 6, 6, 5, 4, 3, 3, 3, 3, 3, 3, 4, 5, 6, 8, 8, 9,11,14,14,14),
(  13,10, 9, 8, 6, 6, 5, 4, 4, 4, 3, 3, 2, 3, 4, 5, 6, 8, 9, 9,11,12,14,14),
(  16,13,12,11, 9, 6, 5, 5, 4, 4, 4, 3, 2, 3, 3, 4, 5, 7, 8,10,14,16,16,16),
(  13,14,14,14,10, 8, 7, 7, 5, 4, 3, 3, 2, 3, 3, 4, 5, 5, 7, 9,11,14,14,14),
(  13,14,14,14,10, 8, 7, 7, 5, 4, 3, 3, 2, 3, 3, 4, 5, 5, 7, 9,11,14,14,14),
(  13,14,14,14,10, 8, 7, 7, 5, 4, 3, 3, 2, 3, 3, 4, 5, 5, 7, 9,11,14,14,14),
(  13,14,14,14,10, 8, 7, 7, 5, 4, 3, 3, 2, 3, 3, 4, 5, 5, 7, 9,11,14,14,14),
(  13,14,14,14,10, 8, 7, 7, 5, 4, 3, 3, 2, 3, 3, 4, 5, 5, 7, 9,11,14,14,14),
(  13,14,14,14,10, 8, 7, 7, 5, 4, 3, 3, 2, 3, 3, 4, 5, 5, 7, 9,11,14,14,14),
(  13,14,14,14,10, 8, 7, 7, 5, 4, 3, 3, 2, 3, 3, 4, 5, 5, 7, 9,11,14,14,14),
(  13,14,14,14,10, 8, 7, 7, 5, 4, 3, 3, 2, 3, 3, 4, 5, 5, 7, 9,11,14,14,14),
(  13,14,14,14,10, 8, 7, 7, 5, 4, 3, 3, 2, 3, 3, 4, 5, 5, 7, 9,11,14,14,14),
(  13,14,14,14,10, 8, 7, 7, 5, 4, 3, 3, 2, 3, 3, 4, 5, 5, 7, 9,11,14,14,14),
(  13,14,14,14,10, 8, 7, 7, 5, 4, 3, 3, 2, 3, 3, 4, 5, 5, 7, 9,11,14,14,14),
(  13,14,14,14,10, 8, 7, 7, 5, 4, 3, 3, 2, 3, 3, 4, 5, 5, 7, 9,11,14,14,14),
(  13,14,14,14,10, 8, 7, 7, 5, 4, 3, 3, 2, 3, 3, 4, 5, 5, 7, 9,11,14,14,14),
(  13,14,14,14,10, 8, 7, 7, 5, 4, 3, 3, 2, 3, 3, 4, 5, 5, 7, 9,11,14,14,14),
(  13,14,14,14,10, 8, 7, 7, 5, 4, 3, 3, 2, 3, 3, 4, 5, 5, 7, 9,11,14,14,14));

  differential_region_power_codes: array[0..MAX_NUM_REGIONS - 1, 0..DIFF_REGION_POWER_LEVELS - 1] of int32 = (
( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0				),
( 8,38,18,10, 7, 6, 3, 2, 0, 1, 7, 6, 5, 4,11,78,158,318,1278,1279,2552,2553,2554,2555			),
( 36, 8, 3, 5, 0, 1, 7, 6, 4, 3, 2, 5, 3, 4, 5,19,74,150,302,1213,1214,1215,2424,2425			),
( 2582,644,160,41, 5,11, 7, 5, 4, 1, 0, 6, 4, 7, 3, 6, 4,21,81,323,1290,5167,10332,10333		),
( 2940,366,181,180,47,46,27,10, 8, 5, 1, 0, 3, 7, 4, 9,12,26,44,182,734,2941,2942,2943			),
( 3982,7967,994,249,63,26,19,18,14, 8, 6, 1, 0, 2, 5, 7,12,30,27,125,496,1990,15932,15933		),
( 3254,1626,407,206,202,100,30,14, 3, 5, 3, 0, 2, 4, 2,13,24,31,102,207,812,6511,13020,13021		),
( 1110,2216,1111,139,35, 9, 3,20,11, 4, 2, 1, 3, 3, 1, 0,21, 5,16,68,276,2217,2218,2219			),
( 1013,1014,127,62,29, 6, 4,16, 0, 1, 3, 2, 3, 1, 5, 9,17, 5,28,30,252,1015,2024,2025			),
( 381,380,372,191,94,44,16,10, 7, 3, 1, 0, 2, 6, 9,17,45,92,187,746,1494,2991,5980,5981			),
( 3036,758,188,45,43,10, 4, 3, 6, 4, 2, 0, 3, 7,11,20,42,44,46,95,378,3037,3038,3039			),
( 751,92,45,20,26, 4,12, 7, 4, 0, 4, 1, 3, 5, 5, 3,27,21,44,47,186,374,1500,1501			),
( 45572,5697,2849,1425,357,45,23, 6,10, 7, 2, 2, 3, 0, 4, 6, 7,88,179,713,11392,45573,45574,45575	),
( 2511,5016,5018,5017,312,79,38,36,30,14, 6, 0, 2, 1, 3, 5, 8,31,37,157,626,5019,5020,5021		),
( 2511,5016,5018,5017,312,79,38,36,30,14, 6, 0, 2, 1, 3, 5, 8,31,37,157,626,5019,5020,5021		),
( 2511,5016,5018,5017,312,79,38,36,30,14, 6, 0, 2, 1, 3, 5, 8,31,37,157,626,5019,5020,5021              ),
( 2511,5016,5018,5017,312,79,38,36,30,14, 6, 0, 2, 1, 3, 5, 8,31,37,157,626,5019,5020,5021              ),
( 2511,5016,5018,5017,312,79,38,36,30,14, 6, 0, 2, 1, 3, 5, 8,31,37,157,626,5019,5020,5021              ),
( 2511,5016,5018,5017,312,79,38,36,30,14, 6, 0, 2, 1, 3, 5, 8,31,37,157,626,5019,5020,5021              ),
( 2511,5016,5018,5017,312,79,38,36,30,14, 6, 0, 2, 1, 3, 5, 8,31,37,157,626,5019,5020,5021              ),
( 2511,5016,5018,5017,312,79,38,36,30,14, 6, 0, 2, 1, 3, 5, 8,31,37,157,626,5019,5020,5021              ),
( 2511,5016,5018,5017,312,79,38,36,30,14, 6, 0, 2, 1, 3, 5, 8,31,37,157,626,5019,5020,5021              ),
( 2511,5016,5018,5017,312,79,38,36,30,14, 6, 0, 2, 1, 3, 5, 8,31,37,157,626,5019,5020,5021              ),
( 2511,5016,5018,5017,312,79,38,36,30,14, 6, 0, 2, 1, 3, 5, 8,31,37,157,626,5019,5020,5021              ),
( 2511,5016,5018,5017,312,79,38,36,30,14, 6, 0, 2, 1, 3, 5, 8,31,37,157,626,5019,5020,5021              ),
( 2511,5016,5018,5017,312,79,38,36,30,14, 6, 0, 2, 1, 3, 5, 8,31,37,157,626,5019,5020,5021              ),
( 2511,5016,5018,5017,312,79,38,36,30,14, 6, 0, 2, 1, 3, 5, 8,31,37,157,626,5019,5020,5021              ),
( 2511,5016,5018,5017,312,79,38,36,30,14, 6, 0, 2, 1, 3, 5, 8,31,37,157,626,5019,5020,5021              ));

  differential_region_power_decoder_tree: array [0..MAX_NUM_REGIONS - 1, 0..DIFF_REGION_POWER_LEVELS - 2, 0..1] of int32 = (
(  (  0,  0),(  0,  0),(  0,  0),(  0,  0),(  0,  0),(  0,  0),(  0,  0),(  0,  0),(  0,  0),(  0,  0),(  0,  0),(  0,  0),(  0,  0),(  0,  0),(  0,  0),(  0,  0),(  0,  0),(  0,  0),(  0,  0),(  0,  0),(  0,  0),(  0,  0),(  0,  0)),
(  (  1,  2),(  3,  4),(  5,  6),(  7,  8),(  9, 10),( 11,-12),(-11,-10),( -8, -9),( -7, -6),(-13, 12),( -5, -4),(  0, 13),( -3,-14),( -2, 14),( -1, 15),(-15, 16),(-16, 17),(-17, 18),( 19, 20),( 21, 22),(-18,-19),(-20,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(  5,  6),(  7,  8),(-10, -9),( -8,-11),( -7, -6),(  9, -5),( 10,-12),( -4, 11),(-13, -3),( 12, -2),( 13,-14),( -1, 14),( 15,-15),(  0, 16),(-16, 17),(-17, 18),(-18, 19),( 20, 21),( 22,-19),(-20,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(  5,  6),(  7,  8),(  9, 10),(-12, 11),(-11,-13),(-10, -9),( 12,-14),( -8, -7),(-15, -6),( 13, -5),(-16, -4),( 14,-17),( 15, -3),( 16,-18),( -2, 17),( 18,-19),( -1, 19),(-20, 20),(  0, 21),( 22,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(  5,  6),(-11,-10),(  7,-12),(  8, -9),(  9,-13),(-14, 10),( -8,-15),(-16, 11),( -7, 12),(-17, -6),( 13, 14),(-18, 15),( -5, -4),( 16, 17),( -3, -2),(-19, 18),( -1, 19),(-20, 20),( 21, 22),(  0,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(  5,  6),(-12,-11),(-13,  7),(  8,-14),(-10,  9),( 10,-15),( -9, 11),( -8, 12),(-16, 13),( -7, -6),(-17, 14),( -5,-18),( 15, -4),( 16,-19),( 17, -3),(-20, 18),( -2, 19),(-21, 20),(  0, 21),( 22, -1),(-22,-23)),
(  (  1,  2),(  3,  4),(  5,  6),(-11,  7),(-12,-10),(-13, -9),(  8,  9),(-14, -8),( 10,-15),( -7, 11),(-16, 12),( -6,-17),( 13, 14),( -5, 15),(-18, 16),( -4, 17),( -3,-19),( 18, -2),(-20, 19),( -1, 20),(  0, 21),( 22,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(  5,-12),(  6,-11),(-10,-13),( -9,  7),(  8,-14),(  9, -8),(-15, 10),( -7,-16),( 11, -6),( 12,-17),( 13, -5),(-18, 14),( 15, -4),(-19, 16),( 17, -3),(-20, 18),( 19, 20),( 21, 22),(  0, -2),( -1,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(  5,-12),(  6,-13),(-11,-10),(  7,-14),(  8, -9),(  9,-15),( -8, 10),( -7,-16),( 11, 12),( -6,-17),( -5, 13),( 14, 15),(-18, -4),(-19, 16),( -3, 17),( 18, -2),(-20, 19),( 20, 21),( 22,  0),( -1,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(  5,  6),(-11,-10),(-12, -9),(  7,  8),(-13, -8),(  9,-14),( -7, 10),( -6,-15),( 11, 12),( -5,-16),( 13, 14),(-17, 15),( -4, 16),( 17,-18),( 18, -3),( -2, 19),( -1,  0),(-19, 20),(-20, 21),( 22,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(  5,  6),(-11,  7),(-10,-12),( -9,  8),( -8,-13),(  9, -7),( 10,-14),( -6, 11),(-15, 12),( -5, 13),(-16, -4),( 14, 15),(-17, -3),(-18, 16),( 17,-19),( -2, 18),(-20, 19),( -1, 20),( 21, 22),(  0,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(  5,-12),(  6,-11),(  7,  8),(-10,-13),( -9,  9),( -8,-14),( 10, -7),( 11,-15),( -6, 12),( -5, 13),( -4,-16),( 14, 15),( -3,-17),( 16, 17),(-18, -2),( 18,-19),( -1, 19),(-20, 20),(-21, 21),( 22,  0),(-22,-23)),
(  (  1,  2),(  3,  4),(  5,-12),(-13,  6),(-11,  7),(-14,  8),(-10,  9),(-15, -9),( -8, 10),( -7,-16),( 11, -6),( 12, -5),(-17, 13),( 14,-18),( 15, -4),( 16,-19),( 17, -3),( 18, -2),( 19, -1),(-20, 20),( 21, 22),(  0,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(-12,  5),(-11,-13),(  6,-14),(-10,  7),(  8,-15),( -9,  9),(-16, 10),( -8,-17),( 11, 12),( -7,-18),( -6, 13),( 14, -5),( 15,-19),( -4, 16),(-20, 17),( 18, 19),( 20, 21),( 22,  0),( -1, -3),( -2,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(-12,  5),(-11,-13),(  6,-14),(-10,  7),(  8,-15),( -9,  9),(-16, 10),( -8,-17),( 11, 12),( -7,-18),( -6, 13),( 14, -5),( 15,-19),( -4, 16),(-20, 17),( 18, 19),( 20, 21),( 22,  0),( -1, -3),( -2,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(-12,  5),(-11,-13),(  6,-14),(-10,  7),(  8,-15),( -9,  9),(-16, 10),( -8,-17),( 11, 12),( -7,-18),( -6, 13),( 14, -5),( 15,-19),( -4, 16),(-20, 17),( 18, 19),( 20, 21),( 22,  0),( -1, -3),( -2,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(-12,  5),(-11,-13),(  6,-14),(-10,  7),(  8,-15),( -9,  9),(-16, 10),( -8,-17),( 11, 12),( -7,-18),( -6, 13),( 14, -5),( 15,-19),( -4, 16),(-20, 17),( 18, 19),( 20, 21),( 22,  0),( -1, -3),( -2,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(-12,  5),(-11,-13),(  6,-14),(-10,  7),(  8,-15),( -9,  9),(-16, 10),( -8,-17),( 11, 12),( -7,-18),( -6, 13),( 14, -5),( 15,-19),( -4, 16),(-20, 17),( 18, 19),( 20, 21),( 22,  0),( -1, -3),( -2,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(-12,  5),(-11,-13),(  6,-14),(-10,  7),(  8,-15),( -9,  9),(-16, 10),( -8,-17),( 11, 12),( -7,-18),( -6, 13),( 14, -5),( 15,-19),( -4, 16),(-20, 17),( 18, 19),( 20, 21),( 22,  0),( -1, -3),( -2,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(-12,  5),(-11,-13),(  6,-14),(-10,  7),(  8,-15),( -9,  9),(-16, 10),( -8,-17),( 11, 12),( -7,-18),( -6, 13),( 14, -5),( 15,-19),( -4, 16),(-20, 17),( 18, 19),( 20, 21),( 22,  0),( -1, -3),( -2,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(-12,  5),(-11,-13),(  6,-14),(-10,  7),(  8,-15),( -9,  9),(-16, 10),( -8,-17),( 11, 12),( -7,-18),( -6, 13),( 14, -5),( 15,-19),( -4, 16),(-20, 17),( 18, 19),( 20, 21),( 22,  0),( -1, -3),( -2,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(-12,  5),(-11,-13),(  6,-14),(-10,  7),(  8,-15),( -9,  9),(-16, 10),( -8,-17),( 11, 12),( -7,-18),( -6, 13),( 14, -5),( 15,-19),( -4, 16),(-20, 17),( 18, 19),( 20, 21),( 22,  0),( -1, -3),( -2,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(-12,  5),(-11,-13),(  6,-14),(-10,  7),(  8,-15),( -9,  9),(-16, 10),( -8,-17),( 11, 12),( -7,-18),( -6, 13),( 14, -5),( 15,-19),( -4, 16),(-20, 17),( 18, 19),( 20, 21),( 22,  0),( -1, -3),( -2,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(-12,  5),(-11,-13),(  6,-14),(-10,  7),(  8,-15),( -9,  9),(-16, 10),( -8,-17),( 11, 12),( -7,-18),( -6, 13),( 14, -5),( 15,-19),( -4, 16),(-20, 17),( 18, 19),( 20, 21),( 22,  0),( -1, -3),( -2,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(-12,  5),(-11,-13),(  6,-14),(-10,  7),(  8,-15),( -9,  9),(-16, 10),( -8,-17),( 11, 12),( -7,-18),( -6, 13),( 14, -5),( 15,-19),( -4, 16),(-20, 17),( 18, 19),( 20, 21),( 22,  0),( -1, -3),( -2,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(-12,  5),(-11,-13),(  6,-14),(-10,  7),(  8,-15),( -9,  9),(-16, 10),( -8,-17),( 11, 12),( -7,-18),( -6, 13),( 14, -5),( 15,-19),( -4, 16),(-20, 17),( 18, 19),( 20, 21),( 22,  0),( -1, -3),( -2,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(-12,  5),(-11,-13),(  6,-14),(-10,  7),(  8,-15),( -9,  9),(-16, 10),( -8,-17),( 11, 12),( -7,-18),( -6, 13),( 14, -5),( 15,-19),( -4, 16),(-20, 17),( 18, 19),( 20, 21),( 22,  0),( -1, -3),( -2,-21),(-22,-23)),
(  (  1,  2),(  3,  4),(-12,  5),(-11,-13),(  6,-14),(-10,  7),(  8,-15),( -9,  9),(-16, 10),( -8,-17),( 11, 12),( -7,-18),( -6, 13),( 14, -5),( 15,-19),( -4, 16),(-20, 17),( 18, 19),( 20, 21),( 22,  0),( -1, -3),( -2,-21),(-22,-23)));

  mlt_quant_centroid: array[0..NUM_CATEGORIES-2, 0..MAX_NUM_BINS - 1] of float = (
(  0.0 ,0.392 ,0.761 ,1.120 ,1.477 ,1.832 ,2.183 ,2.541 ,2.893 ,3.245 ,3.598 ,3.942 ,4.288 ,4.724 ),
(  0.0 ,0.544 ,1.060 ,1.563 ,2.068 ,2.571 ,3.072 ,3.562 ,4.070 ,4.620 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ),
(  0.0 ,0.746 ,1.464 ,2.180 ,2.882 ,3.584 ,4.316 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ),
(  0.0 ,1.006 ,2.000 ,2.993 ,3.985 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ),
(  0.0 ,1.321 ,2.703 ,3.983 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ),
(  0.0 ,1.657 ,3.491 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ),
(  0.0 ,1.964 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ,  0.0 ));

  expected_bits_table: array[0..NUM_CATEGORIES - 1] of int32 = ( 52, 47, 43, 37, 29, 22, 16,   0);

  mlt_sqvh_bitcount_category_0: array[0..195] of int32 = (
 1, 4, 6, 6, 7, 7, 8, 8, 8, 9, 9,10,11,11, 4, 5,
 6, 7, 7, 8, 8, 9, 9, 9, 9,10,11,11, 5, 6, 7, 8,
 8, 9, 9, 9, 9,10,10,10,11,12, 6, 7, 8, 9, 9, 9,
 9,10,10,10,10,11,12,13, 7, 7, 8, 9, 9, 9,10,10,
10,10,11,11,12,13, 8, 8, 9, 9, 9,10,10,10,10,11,
11,12,13,14, 8, 8, 9, 9,10,10,11,11,11,12,12,13,
13,15, 8, 8, 9, 9,10,10,11,11,11,12,12,13,14,15,
 9, 9, 9,10,10,10,11,11,12,13,12,14,15,16, 9, 9,
10,10,10,10,11,12,12,14,14,16,16,16, 9, 9,10,10,
11,11,12,13,13,14,14,15,15,16,10,10,10,11,11,12,
12,13,15,15,16,14,15,15,11,11,11,12,13,13,13,15,
16,16,16,16,14,15,11,11,12,13,13,14,15,16,16,16,
16,16,16,14);

  mlt_sqvh_code_category_0: array[0..195] of int32 = (
    1,    2,    1,   24,   14,   51,    9,   68,  110,   26,  218,   54,  154,  761,    3,   10,
   22,    8,   58,   22,   71,   16,   30,   50,  213,   75,   94,  632,   15,   18,   52,   23,
  107,    5,   54,   63,  239,   46,  276,  271,  851,  252,   28,   10,   12,    1,   22,  133,
  191,   55,  105,  278,  317,  554,  310,  276,   32,   50,   94,   20,  187,  219,   13,  268,
  473,  445,  145,  849, 1277,  623,    1,   14,    0,   55,  238,  121,  120,  269,  318,  530,
  639, 1117,  509,  556,   24,   78,   51,  153,   62,  308,   16,   25,   68, 1058,  428,  277,
 2233, 1114,   92,  108,  141,  223,  270,  381,   24,  212,  760,   35, 1063,  279, 1717, 3439,
    7,   21,  152,   73,  309,  310,   95,  944, 1890, 2232, 1891, 5107,10213, 4981,   61,   62,
    9,   79,  474,  475,  848, 1059, 1056, 1716,  139, 4978, 4983, 4983,  140,  186,   76,  444,
  144,  633, 1057,  838, 2237, 4472, 4473,10212,10212, 4983,   74,   78,  311,  213,  850, 1062,
 1119,  508,  276,  277, 4982, 4473,10212,10212,  208,   70,  555,  418,   68,  510, 2552, 1115,
 4980, 4979, 4982, 4982, 4473,10212,  215,   71,  253,  511,  839, 1718, 2488, 6876, 6877, 4979,
 4979, 4982, 4982, 4473);

 mlt_sqvh_bitcount_category_1: array[0..99] of int32 = (
 1, 4, 5, 6, 7, 8, 8, 9,10,10, 4, 5, 6, 7, 7, 8,
 8, 9, 9,11, 5, 5, 6, 7, 8, 8, 9, 9,10,11, 6, 6,
 7, 8, 8, 9, 9,10,11,12, 7, 7, 8, 8, 9, 9,10,11,
11,13, 8, 8, 8, 9, 9,10,10,11,12,14, 8, 8, 8, 9,
10,11,11,12,13,15, 9, 9, 9,10,11,12,12,14,14,14,
 9, 9, 9,10,11,12,14,16,14,14,10,10,11,12,13,14,
16,16,16,14);

  mlt_sqvh_code_category_1: array[0..99] of int32 = (
    1,    2,   11,   27,   31,    9,  120,   31,  275,  310,    1,    0,   12,    5,   33,   54,
  102,  111,  246,  448,   10,   14,   31,   39,   59,  100,  114,  202,  485,  969,   24,   26,
   36,   52,  103,   30,  120,  242,   69, 1244,   35,   32,   14,   61,  113,  117,  233,  486,
  487, 2491,   13,   12,   69,  110,  149,   35,  495,  449, 1978, 7751,   76,   75,  122,  136,
  213,   68,  623,  930, 3959, 9961,  115,   16,  107,  225,  424,  850, 1936, 7916, 4981, 4981,
  148,  154,  243,  407,  988,  851, 7750,19920, 7916, 4981,  406,  274,  464,  931, 3874, 7917,
19921,19920,19920, 7916);

  mlt_sqvh_bitcount_category_2: array[0..48] of int32 = (
 1, 4, 5, 7, 8, 9,10, 3, 4, 5, 7, 8, 9,10, 5, 5,
 6, 7, 8,10,10, 7, 6, 7, 8, 9,10,12, 8, 8, 8, 9,
10,12,14, 8, 9, 9,10,11,15,16, 9,10,11,12,13,16,
15);

  mlt_sqvh_code_category_2: array[0..48] of int32 = (
    1,    0,   10,   11,   28,   62,  363,    3,    2,    9,    8,   24,   53,  352,    7,    8,
   13,   25,   89,   74,  355,   10,   23,   24,   29,   55,  354, 1449,   25,   19,   30,   52,
  108,  438, 5793,   91,   36,   63,  353,  725,11584,23170,  180,   75,  218,  439, 2897,23171,
11584);

  mlt_sqvh_bitcount_category_3: array[0..624] of int32 = (
 2, 4, 6, 8,10, 5, 5, 6, 8,10, 7, 8, 8,10,12, 9,
 9,10,12,15,10,11,13,16,16, 5, 6, 8,10,11, 5, 6,
 8,10,12, 7, 7, 8,10,13, 9, 9,10,12,15,12,11,13,
16,16, 7, 9,10,12,15, 7, 8,10,12,13, 9, 9,11,13,
16,11,11,12,14,16,12,12,14,16,14, 9,11,12,16,16,
 9,10,13,15,16,10,11,12,16,16,13,13,16,16,16,16,
16,15,16,16,11,13,16,16,15,11,13,15,16,16,13,13,
16,16,16,14,16,16,16,16,16,16,16,16,16, 4, 6, 8,
10,13, 6, 6, 8,10,13, 9, 8,10,12,16,10,10,11,15,
16,13,12,14,16,16, 5, 6, 8,11,13, 6, 6, 8,10,13,
 8, 8, 9,11,14,10,10,12,12,16,13,12,13,15,16, 7,
 8, 9,12,16, 7, 8,10,12,14, 9, 9,10,13,16,11,10,
12,15,16,13,13,16,16,15, 9,11,13,16,16, 9,10,12,
15,16,10,11,13,16,16,13,12,16,16,16,16,16,16,16,
16,11,13,16,16,16,11,13,16,16,16,12,13,15,16,16,
16,16,16,16,16,16,16,16,16,16, 6, 8,11,13,16, 8,
 8,10,12,16,11,10,11,13,16,12,13,13,15,16,16,16,
14,16,15, 6, 8,10,13,16, 8, 8,10,12,16,10,10,11,
13,16,13,12,13,16,16,14,14,14,16,16, 8, 9,11,13,
16, 8, 9,11,16,14,10,10,12,15,16,12,12,13,16,16,
15,16,16,16,16,10,12,15,16,16,10,12,12,14,16,12,
12,13,16,16,14,15,16,16,16,16,16,16,16,16,12,15,
15,16,16,13,13,16,16,14,14,16,16,16,16,16,16,16,
16,16,14,15,16,16,16, 8,10,13,15,16,10,11,13,16,
16,13,13,14,16,16,16,16,16,16,16,16,16,16,16,16,
 8,10,11,15,16, 9,10,12,16,16,12,12,15,16,16,16,
14,16,16,16,16,16,16,16,16, 9,11,14,16,16,10,11,
13,16,16,14,13,14,16,16,16,15,15,16,16,16,16,16,
16,16,11,13,16,16,16,11,13,15,16,16,13,16,16,16,
16,16,16,16,16,16,16,16,16,16,16,15,16,16,16,16,
14,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
16,16,16,16, 9,13,16,16,16,11,13,16,16,16,14,15,
16,16,16,15,16,16,16,16,16,16,16,16,16, 9,13,15,
15,16,12,13,14,16,16,16,15,16,16,16,16,16,16,16,
16,16,16,16,16,16,11,13,15,16,16,12,14,16,16,16,
16,16,16,16,16,16,16,16,16,16,16,15,15,16,16,16,
16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,15,
16,16,13,16,16,16,16,16,16,16,16,16,16,16,16,16,
16);

  mlt_sqvh_code_category_3: array[0..624] of int32 = (
    3,    8,   46,  145,  228,    4,    8,   47,   28,  455,   89,    2,  180,    5, 1335,  250,
   12,  644, 1311,  139,  729,  251,  870, 2172, 2211,    5,   23,  112,  334, 1469,   21,    3,
    5,  111, 2014,   88,   79,  152,  124, 2685,  297,   48,  110, 1310,  149,  501, 1231,  153,
 2267, 2569,   57,   13,  653, 2587,  143,   75,  124,  118, 2611, 5242,   61,   50,  253, 3633,
 2216,  476,   39,   57, 1926, 2236, 2586, 1329, 1920, 2566, 1926,  296,  233, 2590, 2240, 2217,
  253,  613,  867,  144,  318,  614,  252, 2589, 2242, 2218,  872,  866, 2187, 2296, 2155, 2568,
 2227,  150, 2567, 2296,  199, 2686, 2160, 2290,19145,  232, 2680,  128, 2192, 2212, 2684,  793,
 2281, 2223, 2242, 1934, 2165, 2146, 2291, 2296, 2222, 2189, 2187, 2296, 2296,    6,    4,   82,
  725, 3632,   15,   21,   56,  599,  148,    3,  162,   42,  411, 2301,  735,  654,  930,  137,
 2586,  869, 1334, 1931, 2300, 2213,    9,   22,  146, 1290, 5240,    5,   12,   53,  630,  875,
   80,    9,    8,   86, 2002,  210,  117,   56, 2019, 2162,  146,  397,  868,  131, 2151,   77,
  160,  365, 2610, 2252,   59,   54,   41, 2591, 1928,  226,   14,  121, 5792, 2295, 1197,  728,
  408,  130, 2157, 3635,  155, 2573, 2587,  130,  314,   64,  144, 2173, 2176,  115,   30,  409,
  153, 2590,  631,   26, 4787, 2221, 2174, 2683, 1863, 2572,  319, 2150, 2177, 2194, 2571, 2257,
  319,   65,  145, 2251, 2156, 2161,  909,  864, 2193, 2197, 2246, 2588, 5797,  156, 2258, 2221,
 2158, 2199, 2214, 2152,  319, 2188, 2264, 2572,  319,  319,   30,  117,  219,  865, 2263,  147,
  127,  239,  410, 2247,   27,  324, 1468, 2681, 2180, 1328, 5241,  147,  142, 2237, 2241, 2245,
 1921, 2262,  142,   41,   11,  505, 2682, 2591,    0,   26,  229, 2015, 2577,  464,   98,   87,
 5243, 2166,  149, 2016, 5244, 2190, 2198, 9573,11598,11599, 2235, 2190,  144,  298, 1004, 5245,
 2277,  156,  104,  254, 2560, 1922,  612,  325, 2017,  129, 2588, 2608, 1330,  871, 2144, 2145,
  132, 2147, 2148, 2149, 2144,  119, 1331,  133, 2153, 2154,  211,   58, 2609, 1923, 2159,  510,
  163, 5246, 2163, 2164, 1924,  134, 2167, 2168, 2168, 2169, 2170, 2171, 2168, 2168, 1332,  135,
  136, 2175, 2153,  150,  873, 2178, 2179, 1923, 1925, 2181, 2182, 2183, 2163, 2184, 2185, 2186,
 2168, 2168, 1924,  134, 2167, 2168, 2168,   58,  326, 2687,  138, 2191,   31,   66,  874, 2195,
 2196,  151,  152, 1927, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2205,
   55,  103, 1230,  140, 2215,  118,   15, 1333, 2219, 2220, 2018,  511,  141, 2224, 2225, 2226,
 1929, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2229,  366, 1005, 1930, 2238, 2239,   12, 1006,
 5247, 2243, 2244, 1932, 3634, 1933, 2248, 2249, 2250,  145,  146, 2253, 2253, 2254, 2255, 2256,
 2253, 2253, 1291, 5793, 2259, 2260, 2261,  477, 5794,  147, 2265, 2266, 5795, 2268, 2269, 2270,
 2270, 2271, 2272, 2273, 2274, 2274, 2275, 2276, 2273, 2274, 2274,  148, 2278, 2279, 2280, 2260,
 1935, 2282, 2283, 2284, 2265, 2285, 2286, 2287, 2270, 2270, 2288, 2289, 2273, 2274, 2274, 2271,
 2272, 2273, 2274, 2274,  233, 5796, 2292, 2293, 2294, 1292, 3724, 2297, 2298, 2299, 2000,  151,
 2302, 2303, 2200,  152, 2561, 2562, 2563, 2205, 2564, 2565, 2204, 2205, 2205,  363,  154,  154,
  155, 2570,   59, 3725, 2001, 2574, 2575, 2576,  157, 2578, 2579, 2224, 2580, 2581, 2582, 2583,
 2229, 2584, 2585, 2228, 2229, 2229,  654, 5798,  158, 2589, 2238, 2392, 2003, 2592, 2593, 2243,
 2594, 2595, 2596, 2597, 2248, 2598, 2599, 2600, 2253, 2253, 2250,  145,  146, 2253, 2253, 2601,
 2602, 2603, 2604, 2260, 2605, 2606, 2607, 6336, 2265, 6337, 6338, 6339, 2270, 2270, 6340, 6341,
 2273, 2274, 2274, 2271, 2272, 2273, 2274, 2274, 6342, 6343, 2259, 2260, 2260,38288,38289,  147,
 2265, 2265, 5795, 2268, 2269, 2270, 2270, 2271, 2272, 2273, 2274, 2274, 2271, 2272, 2273, 2274,
 2274);

  mlt_sqvh_bitcount_category_4: array[byte] of int32 = (
 2, 4, 7,10, 4, 5, 7,10, 7, 8,10,14,11,11,15,15,
 4, 5, 9,12, 5, 5, 8,12, 8, 7,10,15,11,11,15,15,
 7, 9,12,15, 8, 8,12,15,10,10,13,15,14,14,15,13,
11,13,15,15,11,13,15,15,14,15,15,13,15,15,13,13,
 4, 5, 9,13, 5, 6, 9,13, 9, 9,11,15,14,13,15,15,
 4, 6, 9,12, 5, 6, 9,13, 9, 8,11,15,13,12,15,15,
 7, 9,12,15, 7, 8,11,15,10,10,14,15,14,15,15,14,
10,12,15,15,11,13,15,15,15,15,15,14,15,15,14,14,
 6, 9,13,14, 8, 9,12,15,12,12,15,15,15,15,15,15,
 7, 9,13,15, 8, 9,12,15,11,12,15,15,15,15,15,15,
 9,11,15,15, 9,11,15,15,14,14,15,15,15,15,15,15,
14,15,15,15,14,15,15,15,15,15,15,15,14,14,15,15,
 9,12,15,15,12,13,15,15,15,15,15,15,15,15,15,15,
10,12,15,15,12,14,15,15,15,15,15,15,15,15,15,15,
14,15,15,15,15,15,15,15,15,15,15,15,14,14,15,15,
15,15,15,15,15,15,15,15,14,14,15,15,14,14,15,15);

  mlt_sqvh_code_category_4: array[byte] of int32 = (
    1,    2,    4,  572,   10,    0,   69,  712,   91,   10,   46, 9182, 1426, 1430,30172,30194,
    9,   28,   22, 2258,   16,   25,  142, 2179,   15,  111,  719, 1521, 1131, 1437, 1520,30196,
   88,  283, 3803,30193,   13,  236, 2856,30166,  545,  951, 5709, 1522, 3241, 9180,30179, 5709,
 1088, 4356,30410,30175, 1146,  377,30162,30163, 8715,30176,30165, 5709,30197,30184, 5709, 5709,
    1,   23,   28, 5710,   26,   14,   29, 7538,  102,  103, 1429, 1524, 3237, 7060,30401,30201,
   15,   13,  470, 3768,   24,   15,  281, 5747,   24,  181, 1128,30206, 5711, 3531,30156,30158,
  116,  100, 2260,30187,  119,  234, 1764,30171,  716,  883, 9183,30164, 3236, 1528,30180, 9183,
  885, 2870, 1532,30160, 1431, 5708,30192,30205,30402,30168,30173, 9183,30157,30161, 9183, 9183,
   54,   25, 1621,15211,  180,  287, 2261,30198,  808,  811,30411,30413,30414,22986,22987,30411,
   24,  273,  376,30159,  137,  280, 2871, 1523, 1768, 2259, 1525,30167, 1526,30169,30170, 1525,
  443, 1434, 1527,30174,  474, 1769,30177,30178, 3238, 3239,30181,30181,30182,30183,30181,30181,
 3240,30185,30186, 1527, 9181,30188,30189,30177,30190,30191,30181,30181, 3238, 3239,30181,30181,
  440, 2857, 1529,30195, 2294, 7061, 1530,30199,30200, 1531,30202,30411,30203,30204,30411,30411,
  203, 2872,30207,30400,  189,11492,30403,30404,30405,30406,30407, 1525,30408,30409, 1525, 1525,
 8714, 1533,30412, 1527, 1534, 1535,30415,30177,30416,30417,30181,30181, 3238, 3239,30181,30181,
30418,30419, 1527, 1527,30420,30421,30177,30177, 3238, 3239,30181,30181, 3238, 3239,30181,30181);

  mlt_sqvh_bitcount_category_5: array[0..242] of int32 = (
 2, 4, 8, 4, 5, 9, 9,10,14, 4, 6,11, 5, 6,12,10,
11,15, 9,11,15,10,13,15,14,15, 6, 4, 6,12, 6, 7,
12,12,12,15, 5, 7,13, 6, 7,13,12,13,15,10,12,15,
11,13,15,15,15, 7, 8,13,15,11,12,15,15,15, 7,10,
13,15,12,15,15,15,15, 7,15,15, 7,15,15, 7, 6, 7,
 7, 4, 5,11, 5, 7,12,11,12,15, 6, 7,13, 7, 8,14,
12,14,15,11,13,15,12,13,15,15,15, 8, 5, 6,13, 7,
 8,15,12,14,15, 6, 8,14, 7, 8,15,14,15,15,12,12,
15,12,13,15,15,15, 8, 9,13,15,12,13,15,15,15, 8,
11,13,15,13,13,15,15,15, 8,14,15, 8,15,15, 8, 7,
 8, 8, 8,10,15,11,12,15,15,15, 7,10,12,15,12,13,
15,15,15, 8,14,15, 7,15,15, 8, 7, 8, 8, 8,12,15,
12,13,15,15,15, 8,11,13,15,13,15,15,15,15, 8,15,
15, 8,15,15, 8, 7, 8, 8,14,15, 6,15,15, 8, 7, 8,
 8,15,15, 8,15,15, 8, 7, 8, 8, 6, 8, 8, 7, 8, 8,
 7, 8, 8);

  mlt_sqvh_code_category_5: array[0..242] of int32 = (
    0,    5,  220,   10,   16,  443,  390,  391,14333,   11,   26, 1566,   26,   54, 3135,  508,
 1558,28581,  255, 1782,28599,  885, 6208,28578,14335,28579,   54,    9,   35, 3129,   27,   68,
 3537, 1562, 3568,28610,   25,   62, 4078,   58,  118, 7763, 3107, 7758,28563,  778, 3131,28598,
  780, 7123,28630,28593,28586,  118,  243, 6210,28614, 1018, 3567,28601,28611,28570,   68,  388,
 6256,28619, 1559,28562,28606,28565,28591,  118,28594,28571,   62,28618,28590,  118,   58,  118,
  118,    4,   28, 1781,   31,   60, 3134, 1938, 3882,28574,   25,   96, 7757,   49,  126,14244,
 3883,14334,28613, 1769, 4077,28602, 3106, 7756,28582,28621,28566,  126,   14,   61, 4079,   61,
  138,28491, 3536, 8153,28573,   49,   96,12442,  119,  240,28490,12443,28560,28561, 3111, 3580,
28564, 3130, 7759,28567,28568,28569,  240,  444, 6209,28572, 3569, 6211,28575,28576,28577,  138,
  778, 7760,28580, 7761, 7762,28583,28584,28585,  240,14319,28587,   96,28588,28589,  240,  119,
  240,  240,  139,  968,28592, 1554, 3581,28595,28596,28597,   60,  971, 3560,28600, 3582, 7132,
28603,28604,28605,  126,14332,28607,   96,28608,28609,  126,   49,  126,  126,  241, 1558,28612,
 1563, 6257,28615,28616,28617,  138, 1559, 7133,28620, 6220,28622,28623,28624,28625,  240,28626,
28627,   96,28628,28629,  240,  119,  240,  240, 8152,28631,   61,28632,28633,  138,   61,  138,
  138,28634,28635,   96,28636,28637,  240,  119,  240,  240,   49,   96,   96,  119,  240,  240,
  119,  240,  240);

  mlt_sqvh_bitcount_category_6: array[0..31] of int32 = (
 1, 4, 4, 6, 4, 6, 6, 8, 4, 6, 6, 8, 6, 9, 8,10,
 4, 6, 7, 8, 6, 9, 8,11, 6, 9, 8,10, 8,10, 9,11);

  mlt_sqvh_code_category_6: array[0..31] of int32 = (
    1,    2,    4,    2,    5,   29,   24,  101,    3,   31,   28,  105,    3,    5,  102,  424,
    1,   30,    0,  107,   27,  200,  103,  806,    1,    4,  104,  402,    3,  425,  213,  807);

  table_of_bitcount_tables: array[0..NUM_CATEGORIES-2] of pointer = (
    @mlt_sqvh_bitcount_category_0,
    @mlt_sqvh_bitcount_category_1,
    @mlt_sqvh_bitcount_category_2,
    @mlt_sqvh_bitcount_category_3,
    @mlt_sqvh_bitcount_category_4,
    @mlt_sqvh_bitcount_category_5,
    @mlt_sqvh_bitcount_category_6
);

  table_of_code_tables: array[0..NUM_CATEGORIES-2] of pointer = (
    @mlt_sqvh_code_category_0,
    @mlt_sqvh_code_category_1,
    @mlt_sqvh_code_category_2,
    @mlt_sqvh_code_category_3,
    @mlt_sqvh_code_category_4,
    @mlt_sqvh_code_category_5,
    @mlt_sqvh_code_category_6
);

  mlt_decoder_tree_category_0: array[0..179, 0..1] of int32 = (
(   1,   0),(   2,   3),(   4,   5),(   6,   7),(   8,   9),(  -1, -14),(  10,  11),(  12,  13),
(  14,  15),(  16,  17),(  18,  19),( -15,  20),(  21,  22),(  23, -28),(  24,  -2),(  25,  26),
(  27,  28),(  29,  30),(  31,  32),( -29,  33),( -16,  34),(  -3,  35),(  36,  37),( -42,  38),
(  39,  40),(  41,  42),(  43,  44),( -17,  45),( -43,  46),(  47,  48),(  -4,  49),( -56,  50),
(  51,  52),(  53,  54),(  55,  56),( -57,  -5),( -30,  57),(  58,  59),( -18,  60),(  61, -70),
(  62,  63),(  64,  -6),(  65,  66),( -44,  67),( -71,  68),(  69,  70),( -19, -31),( -84,  71),
(  72,  73),(  74,  75),(  76,  77),(  -7,  78),(  79, -20),(  80,  81),( -85,  82),( -98,  83),
( -58,  84),(  85, -32),( -99,  86),(  -8,  87),(  88,  89),( -72, -45),(  90, -33),(  91,-112),
( -21,  92),( -59,-113),( -46,  93),(  -9,  94),( -22,  95),(  96,  97),(  98,  99),( -23, -86),
( 100, 101),( -34, -73),( 102,-126),(-127, -35),( 103, -47),( 104, 105),( 106, 107),(-140,-100),
(-114, -87),( 108, 109),( 110, 111),(-141, -60),( 112, -48),( 113, -24),( -10, -61),( 114,-101),
( 115, 116),( -74, -36),( 117,-128),( 118, -62),( 119, 120),( -37, 121),( -11, -49),( -88, 122),
( 123,-115),(-154, -25),(-142, 124),(-155,-129),( 125, -50),( 126, 127),( -76, -75),( 128, 129),
( -63, -77),(-102, -39),( -38, 130),( -51, 131),( -89,-116),(-117,-156),( 132, -52),( -78, 133),
( 134,-103),( 135, 136),(-143, -65),( 137, -64),(-130,-131),( -90, 138),(-104, -91),( -92, 139),
(-169,-183),( -26,-118),( 140, 141),(-144, -66),( -12, 142),(-168, 143),(-105,-157),( 144,-182),
( 145, 146),( -79, 147),( -53,-170),( 148, 149),( -27,-145),( 150, -80),(-106, -13),(-132, -67),
(-158, -40),(-119, 151),( 152,-107),( 153, 154),( -41,-184),( 155, 156),( -54, 157),(-171, 158),
( -94, 159),(-134,-146),( -93,-133),(-159,-108),( 160, -81),( 161,-160),( 162, -68),(-120,-122),
(-172, 163),( -55, -95),( 164,-109),(-161, -82),(-173,-185),( 165, -69),(-147,-186),( 166, 167),
(-121, -96),( 168,-148),(-174, 169),( 170,-136),( -83, 171),( 172, 173),(-135,-110),(-187, 174),
(-149,-150),( 175,-123),(-162,-163),( -97,-175),(-188, 176),( 177, 178),( 179,-111),(-151,-124),
(-137,-177),(-176,-125),(-164,-138),(-189,-190));

  mlt_decoder_tree_category_1: array[0..92, 0..1] of int32 = (
(   1,   0),(   2,   3),(   4,   5),(   6,   7),(   8, -10),(  -1,   9),(  10,  11),(  12,  13),
( -11,  14),(  15,  16),(  17,  18),( -20,  -2),(  19,  20),( -21,  21),(  22,  23),( -12,  24),
(  25,  26),(  27,  28),(  29,  30),( -30,  31),( -31,  -3),(  32, -22),(  33, -13),(  34,  35),
(  36,  37),(  38,  39),(  40,  -4),( -41, -14),(  41, -40),( -32,  42),(  43, -23),(  44,  45),
(  46,  47),(  48,  -5),( -51, -50),( -42,  49),( -33,  50),( -15,  51),(  52,  53),(  54, -24),
(  55, -43),(  56, -52),(  57, -61),( -60,  58),( -25,  59),( -16, -34),(  -6,  60),( -62,  61),
( -71,  62),( -35,  -7),(  63, -72),( -53, -17),(  64, -44),( -26, -70),(  65, -45),( -36,  66),
( -63,  67),( -80, -54),( -81,  68),( -27,  69),(  70, -82),( -18,  71),(  72, -55),(  73, -64),
(  74, -73),(  75, -46),( -37,  76),( -91,  -8),(  -9,  77),( -90, -83),(  78, -28),(  79, -56),
( -65, -38),( -74,  80),( -19, -57),( -92,  81),( -47, -48),(  82, -66),(  83, -29),( -84,  84),
( -75, -85),( -67, -93),( -39,  85),( -76,  86),( -58,  87),(  88, -49),( -94,  89),(  90, -68),
(  91, -78),( -86, -59),( -77, -95),(  92, -69),( -87, -96));

  mlt_decoder_tree_category_2: array[0..46, 0..1] of int32 = (
(   1,   0),(   2,   3),(   4,   5),(   6,  -7),(  -1,   7),(  -8,   8),(   9,  10),(  11,  12),
(  13, -14),( -15,  -9),(  -2,  14),(  15,  16),(  17,  18),(  19, -16),(  20, -22),( -10,  21),
( -21,  -3),(  22,  23),(  24,  25),( -23, -17),(  26,  27),(  28, -29),( -11, -28),(  29,  30),
(  -4, -24),( -30,  31),(  32, -18),(  33, -35),( -36,  34),( -31, -12),(  35, -25),(  -5, -37),
(  36,  37),( -42,  38),( -19, -43),( -32,  39),( -13, -38),( -26, -20),(  40,  -6),( -44,  41),
(  42, -39),( -33, -45),(  43, -27),(  44, -46),(  45, -34),( -40,  46),( -41, -47));

  mlt_decoder_tree_category_3: array[0..518, 0..1] of int32 = (
(   1,   2),(   3,   4),(   5,   0),(   6,   7),(   8,   9),(  10,  11),(  12,  13),(  14,  15),
(  16,  17),(-125,  18),(  -1,  19),(  20,  21),(  22,  23),(  24,  25),(  -5, -25),(  26,  27),
(  -6,-150),(  28,  29),(  30,  31),(  32,  33),(  34, -30),(  35,  36),(  37,  38),(  39, -31),
(-126,-155),(  40,  41),(-156,  42),(  43,-130),(  44,-131),(-151, -26),(  45,  46),(-250,  47),
(  48,  49),(  50,  51),(  52,-275),(  53,  54),(  -2,  -7),(  55,  56),(  57,  58),(  59,  60),
(  61,  62),(  63,  64),(  65,  66),(  67,  68),(  69,  70),(  71, -50),(  72,-180),(  73,  74),
(  75,  76),(  77, -55),(  78,-175),(  79, -36),(  80,  81),( -35, -10),(  82,  83),(-280,  84),
( -11,  85),(  86, -32),(  87,  88),(  89,-161),(  90,-276),(  91,  92),(-281,  93),(  -8,  94),
(  95,  96),(  97,-157),(-181,-400),(-132,  98),(-375,  99),(-160, 100),(-127, 101),( -27, 102),
( 103,-251),( -56, 104),( 105,-256),(-300,  -3),(-152,-255),( 106, 107),( -37, 108),(-305, 109),
(-176, 110),(-136, 111),( -12, 112),( 113, 114),( 115,-135),( 116, 117),(-162, 118),( -16, -51),
(-186, 119),( 120, 121),( 122, 123),( -41, 124),( -61, 125),( 126, 127),( 128, 129),( 130, -60),
( 131, 132),(-306, 133),( 134,-205),(-405, 135),( 136, 137),( 138, 139),(-185, 140),( 141,-500),
( -15, 142),( 143, -80),( -75, -40),(-301, 144),( 145, 146),(-200, 147),( 148, 149),( 150, 151),
( 152,-525),( 153,-177),(-425, 154),( 155, -13),(-430, 156),( 157,-406),( 158, 159),(-206,-380),
( 160, 161),( 162, 163),( 164,-182),(-137, 165),(-286, 166),( 167,-401),( 168, 169),( -42, -33),
( 170,-166),( -57,-325),( 171,-187),( -38, 172),( 173, 174),(-165,-330),(  -4,-282),( 175,-257),
(-261,-311),(-376, 176),( 177, 178),( -28, 179),( 180,  -9),(-285, 181),( 182, 183),( 184,-277),
( 185,-133),(-310, -81),( -85, 186),(-158,-210),( -17, 187),( 188, 189),( 190, -52),(-141, 191),
( 192,-128),(-191, -20),( 193,-140),( 194, 195),(-211,-260),( 196, 197),( 198, 199),( 200, -66),
(-201,-225),(-381, 201),( 202, 203),( 204, 205),( 206, 207),(-163,-287),( 208,-100),( 209, 210),
( 211, 212),( 213,-252),(-105, -76),( 214, 215),( 216, -21),( -86, -62),(-307, 217),( -65,-455),
(-550, 218),( 219, 220),( 221, 222),( 223, 224),( 225,-230),(-142, 226),(-302,-426),(-431, 227),
( 228, 229),( 230,-190),(-402, -46),(-153,-450),(-505, 231),( 232, 233),( 234, 235),( 236, 237),
( 238, 239),(-262, -29),( 240, 241),( 242, 243),(-167, -67),(-331,-530),( 244, 245),( 246, 247),
( 248, 249),( 250, 251),( 252, 253),( 254, 255),( 256, 257),( 258, 259),( 260, 261),( 262,-336),
( 263,-171),(-192,-207),(-258,-138),( 264, 265),( 266, 267),( 268, 269),( 270, 271),( 272, 273),
( 274, -45),(-335,-411),( -43, -18),(-265, -71),(-316,-326),(-350,-407),(-146, -14),( 275, 276),
( 277, 278),( 279, 280),( 281,-216),( -34,-283),(-291,-312),(-410,-168),(-555, 282),( -70, -53),
(-235, -87),( -77,-183),(-315,-332),(-178, -58),( 283, 284),( 285, 286),( 287, 288),( 289, 290),
( 291, 292),( 293, 294),( 295, 296),( 297, 298),(-202,-226),(-170,-267),(-134,-290),(-355,-385),
(-386, -47),(-526,-196),( 299, 300),( 301, 302),( 303, 304),( 305, 306),( 307, 308),( 309, 310),
( 311, 312),( 313, 314),( 315, 316),( 317, 318),( 319, 320),( 321, 322),( 323, 324),( 325,-111),
(-231,-253),( -91, -82),(-172,-145),( -22,-317),( -90,-356),(-382,-159),( 326, 327),( 328, 329),
( 330, 331),( 332, 333),( 334, 335),(-106,-263),(-278,-215),(-110, -39),(-101,-377),(-129, -63),
(-436,-195),(-506,-531),( 336,-212),(-154,-266),( -59,-288),(-292,-303),(-337,-432),(-188,-451),
(-456,-460),(-501,-236),(-551, 337),( 338, 339),( 340, 341),( 342, 343),( 344, 345),( 346, 347),
( 348, 349),( 350, 351),( 352, 353),( 354, 355),( 356, 357),( 358, 359),( 360, 361),( 362, 363),
( 364, 365),( 366, 367),( 368, 369),( 370, 371),( 372, 373),( 374, 375),( 376, 377),( 378, 379),
( 380, 381),( 382, 383),( 384, 385),( 386, 387),( 388, 389),( 390, 391),( 392, 393),( 394, 395),
( 396, 397),( 398, 399),( 400, 401),( 402, 403),( 404, 405),( 406, 407),( -72,-272),(-309,-333),
(-340,-360),( -68,-387),(-184,-416),(-427,-147),(-435,-437),(-115,-480),(-510,-532),(-164,-556),
( 408,-295),(-296,-297),(-107,-313),(-193,-173),(-320,-327),(-341,-351),(-352,-143),(-378, -19),
(-403,-412),(-268, -54),( -83,-441),(-442,-457),(-475, -44),( -97,-511),(-515,-208),(-527,-528),
(-237,-536),(-552, 409),( 410, 411),( 412, 413),( 414, 415),( 416, 417),( 418, 419),( 420, 421),
( 422, 423),( 424, 425),( 426, 427),( 428, 429),( 430, 431),( 432, 433),( 434, 435),( 436, 437),
( 438, 439),( 440, 441),( 442, 443),( 444, 445),( 446, 447),( 448, 449),( 450, 451),( 452, 453),
( 454, 455),( 456, 457),( 458, 459),( 460, 461),( 462, 463),( 464, 465),( 466, 467),( 468, 469),
( 470, 471),( 472, 473),( 474, 475),( 476, 477),( 478, 479),( 480, 481),( 482, 483),( 484, 485),
( 486, 487),( 488, 489),( 490, 491),( 492, 493),( 494, 495),( 496, 497),( 498, 499),( 500, 501),
( 502, 503),( 504, 505),( 506, 507),( 508, 509),( 510, 511),( 512, 513),( 514, 515),( 516, 517),
( 518,-104),( -84,-218),(-318,-319),(-117,-321),(-322,-323),(-219,-174),(-243,-328),(-329, -94),
(-228,-194),(-240,-334),(-102,-229),(-169,-338),(-339,-116),(-289,-342),(-343,-345),(-346,-347),
( -23,-203),(-214,-353),(-204,-220),(-357,-358),(-264,-361),(-362,-363),(-365,-366),(-367, -92),
(-245,-121),(-293,-379),(-108,-232),(-221,-383),(-384,-233),(-294,-241),(-388,-389),(-390,-391),
(-392,-393),(-394,-395),(-396,-397),(-398, -24),(-109,-149),(-242,-404),( -64, -79),( -89,-408),
(-409,-213),(-120,-113),(-413,-414),(-415, -96),(-417,-418),(-419,-420),(-421,-422),(-423,-298),
( -69,-269),(-428,-429),( -78,-270),( -88,-433),(-434,-271),(-234,-259),(-438,-439),(-440,-227),
(-179,-443),(-445,-446),(-447,-223),(-238,-452),(-453,-454),(-273,-254),(-246,-458),(-459, -48),
(-461,-462),(-463,-465),(-466,-467),(-468,-470),(-471,-304),(-476,-477),(-478,-112),(-481,-482),
(-483,-485),(-486,-487),(-490,-491),(-103,-118),(-502,-503),(-504,-189),( -93,-507),(-508,-509),
(-148,-139),(-512,-513),(-308,-516),(-517,-518),(-520,-521),( -73, -98),( -95, -49),(-529,-222),
(-217,-197),(-533,-534),(-535,-284),(-537,-538),(-540,-541),(-542,-543),(-545,-546),(-144,-198),
(-314,-553),(-209,-279),(-557,-558),(-560,-561),(-562,-563),(-565,-566),(-567,-575),(-576,-577),
(-578,-580),(-581,-582),(-583,-585),(-586,-587),(-590,-591),(-600,-601),(-605,-606));

  mlt_decoder_tree_category_4: array[0..207, 0..1] of int32 = (
(   1,   2),(   3,   0),(   4,   5),(   6,   7),(   8,   9),(  10,  11),(  12, -64),(  -1,  13),
(  14, -16),(  -4,  15),(  16,  17),(  18, -80),(  -5,  19),(  20,  21),( -20,  22),(  23, -65),
( -84, -21),( -68,  24),( -17,  25),(  26,  27),(  28, -81),( -69, -85),(  29,  30),(  31,  32),
(-128,  33),(  34,  35),(  -2,  36),(  37,  38),(-144,  39),(  40,  -6),(  41,  42),( -32,  43),
(  44,  -8),(  45, -25),( -96,  46),(  47,-100),(  -9,  48),(  49, -36),(  50, -24),(  51,  52),
(  53,-148),(  54,  55),( -22,  56),(  57,  58),(-132, -89),(  59,  60),(-101,  61),( -37,  62),
( -18,  63),( -88,-129),( -66, -70),( -97,  64),( -72, -73),(  65,-145),(-149, -86),(  66, -33),
(  67,-133),(  68,  69),(  70,  71),(-192,  72),(  73,-160),( -82,  74),(-164,  75),( -10,  76),
(  77,-208),(  78, -40),(  79,  80),(  -3,  81),(  -7,  82),(  83,  84),(-104,  85),(  86, -26),
(  87,-105),(  88,-112),(  89,  90),(  91, -41),(  92,  93),(  94,  95),( -48,  96),( -90,  97),
(  98, -28),( -52,  99),( -12, 100),( 101, -74),( -13,-116),(-161, 102),( 103, -29),(-102, 104),
(-152,-165),( 105, 106),( 107, 108),( 109, 110),( 111,-212),( 112, 113),(-136, 114),( 115,-137),
( 116, -23),( -19,-153),( -98,-134),(-196, 117),( 118, 119),( -38,-193),(-113,-150),(-209, 120),
( 121, -93),( -83, 122),( 123, 124),( 125, 126),( 127, 128),( 129, 130),( 131, -34),(-146, -53),
( 132, 133),( 134, 135),( 136, 137),( 138,-130),( -49, 139),( 140, 141),(-117, -42),( -67, -92),
( 142, -87),( -77,-197),( -71, 143),( 144, 145),( 146, 147),( 148, 149),( 150, 151),( 152, 153),
( 154, 155),( 156, 157),( 158, 159),( 160, 161),( 162, 163),( 164, 165),( 166, 167),( 168, 169),
(-108, -76),(-168,-169),(-176, -44),(-224, -56),( -45,-180),( -11,-106),(-213, 170),( 171, 172),
( 173, 174),( 175, 176),( 177, 178),( 179, 180),( 181, 182),( 183, 184),( 185, 186),( 187, 188),
( 189, 190),( 191, 192),( 193, 194),( 195, 196),( 197, 198),( 199, 200),( 201, 202),( 203, 204),
( 205, 206),( 207,-131),( -30, -27),( -43,-151),( -75,-154),(-156,-162),(-109,-194),(-198,-201),
(-114,-225),(-228,-229),(-141,-142),( -94,-124),( -95,-147),(-115,-125),( -54, -55),(-107, -58),
( -39,-155),(-121,-157),(-158,-103),( -14,-122),(-163, -51),( -57,-166),(-167, -46),(-110,-170),
(-172,-173),( -61,-177),(-178, -99),(-181,-182),(-184,-185),(-118, -35),( -15,-195),( -31, -60),
(-135,-199),(-200, -79),(-202,-204),(-205,-119),( -91,-210),(-211, -78),(-120,-214),(-215,-216),
(-217,-218),(-220,-221),( -50,-138),(-226,-139),(-140,-230),(-232,-233),(-240,-241),(-244,-245)
);

  mlt_decoder_tree_category_5: array[0..190, 0..1] of int32 = (
(   1,   2),(   0,   3),(   4,   5),(   6,   7),(   8,   9),(  10,  11),( -81,  -1),(  12,  13),
(  14, -27),(  -3,  -9),(  15,  16),(  17,  18),(  19,  20),(-108,  21),(  -4,  22),(  23, -36),
( -12,  24),( -82,  25),(  26, -84),(  27, -90),( -10, -30),(  28,  29),(  30, -28),(  31,-117),
( -13,  32),( -39,  33),(  34,-109),(  35, -93),( -85,-111),( -37,  36),( -31,  37),( -91,  38),
(  39,  40),( -40,-120),(  41,  42),(-118,  43),( -94,  44),(-112,-162),(  45,  46),(  -2,  47),
(  48,  49),(-121,-189),(  50, -54),(  51,  52),(  53, -18),(  54,  55),(  -6,  56),(  57,  -5),
(-135,  58),(  59,  60),(  61,  62),( -63,  63),(  64,  -7),( -15,  65),(  66,  67),( -45,  68),
(  69,  70),(  71, -21),(  72,  73),(  74,  75),(  76,  77),(-163,  78),(  79,-171),(-144,  80),
( -48,  81),( -57,  82),(  83,  84),(-165,  85),( -16,-198),(  86,  87),( -11,  88),(  89, -99),
(  90, -83),( -19,  91),(  92,  93),(  94,  95),(  96,  97),(  98,  99),( -87, 100),( 101, 102),
(-190, -66),( -33,-192),( 103, 104),( 105, 106),(-102, -42),( 107,-126),( 108, -29),(-129, -46),
( -86, -14),(-114, -32),(-172, 109),( 110, -58),( -34,-138),( 111, 112),( 113, 114),( 115, 116),
( 117, 118),( 119, 120),(-127,-166),(-174, 121),( 122, 123),( 124, 125),( -88, -96),( 126,-100),
( -38,-110),( -22,-136),( -55,-139),(-201, 127),( -64,-193),( 128, -49),(-175,-199),( 129, 130),
( 131, 132),( 133, 134),( 135, 136),( 137, 138),( 139, 140),( 141, 142),( 143, 144),( 145, 146),
( 147, 148),( 149, 150),(-103, -92),( -43,-130),(-145,-147),(-148, -41),(-216,-115),(-119,-123),
( -95, 151),( 152, 153),( 154, 155),( 156, 157),( 158, 159),( 160, 161),( 162, 163),( 164, 165),
( 166, 167),( 168, 169),( 170, 171),( 172, 173),( 174, 175),( 176, 177),( 178, 179),( 180, 181),
( 182, 183),( 184, 185),( 186, 187),( 188, 189),( 190,-153),(-180,  -8),( -97, -24),(-122,-113),
(-124,-125),( -67, -44),(-128, -69),(-106,-131),(-132,-133),( -61, -73),(-137,-116),( -89,-140),
(-141,-142),( -23, -25),(-146, -17),(-104,-149),(-150,-151),( -52,-154),(-156,-157),( -76, -70),
(-164, -51),( -72,-167),(-168,-169),( -47, -20),(-173, -59),(-101,-176),(-177,-178),( -68,-181),
(-183,-184),( -35, -60),(-191, -98),( -56,-194),(-195,-196),( -75, -65),(-200,-105),(-202,-203),
(-204,-205),(-207,-208),(-210,-211),( -50,-217),(-219,-220),(-225,-226),(-228,-229)
);

  mlt_decoder_tree_category_6: array[0..30, 0..1] of int32 = (
(   1,   0),(   2,   3),(   4,   5),(   6,   7),(   8, -16),(  -1,  -8),(  -2,  -4),(   9,  10),
(  11,  12),(  13,  14),(  15,  16),(  17, -24),(  -3, -12),(  -6,  18),(  19, -20),( -10,  -5),
( -17,  -9),( -18,  20),(  21,  22),(  23,  24),(  25, -28),(  26,  -7),( -14, -22),( -26, -11),
(  27, -19),( -25, -13),( -21,  28),(  29, -30),( -27,  30),( -15, -29),( -23, -31)
);

  table_of_decoder_tables: array[0..NUM_CATEGORIES - 2] of pointer = (
    @mlt_decoder_tree_category_0,
    @mlt_decoder_tree_category_1,
    @mlt_decoder_tree_category_2,
    @mlt_decoder_tree_category_3,
    @mlt_decoder_tree_category_4,
    @mlt_decoder_tree_category_5,
    @mlt_decoder_tree_category_6
  );

type
  tmax_vector = array[0..MAX_VECTOR_DIMENSION - 1] of int32;
  tmax_regions = array[0..MAX_NUM_REGIONS - 1] of int32;
  tmax_regions4 = array[0..4 * MAX_NUM_REGIONS - 1] of uint32;
  tmax_regionsP1 = array[0..MAX_NUM_REGIONS] of int32;
  tmax_regionsf = array[0..MAX_NUM_REGIONS - 1] of float;
  tmax_rate_control = array[0..MAX_NUM_RATE_CONTROL_POSSIBILITIES - 2] of int32;
  tmax_dct_size = array[0..MAX_DCT_SIZE - 1] of int16;
  tmax_dct_sizef = array[0..MAX_DCT_SIZE - 1] of float;
  tmax_frame = array[0..MAX_BITS_PER_FRAME shr 4 - 1] of uint16;


// --- mostly Delphi specific ---

type
  {*
	Mostly internal.
  }
  unaMTLVector = class(unaObject)
  private
    region_standard_deviation_table: array[0..REGION_POWER_TABLE_SIZE - 1] of float;
    standard_deviation_inverse_table: array[0..REGION_POWER_TABLE_SIZE - 1] of float;
    step_size_inverse_table: array[0..NUM_CATEGORIES - 1] of float;
    //
    region_power_table: array[0..REGION_POWER_TABLE_SIZE - 1] of float;
    region_power_table_boundary: array[0..REGION_POWER_TABLE_SIZE - 1] of float;
    //
    // int_dead_zone: array[0..NUM_CATEGORIES-1] of int32;
    max_bin_plus_one_inverse: array[0..NUM_CATEGORIES - 1] of int32;
  protected
    {*
    }
    function index_to_array(index: int32; out _array: tmax_vector; category: int32): int32;
    {*
    }
    procedure mlt_based_coder_init();
    {*
    }
    procedure categorize(number_of_regions: int32; num_rate_control_possibilities: int32;
		number_of_available_bits: int32;
		const rms_index: tmax_regions;
		out power_categories: tmax_regions;
		out category_balances: tmax_rate_control);
  public
    constructor create();
  end;


type
  {*
	Internal.
  }
  pcos_msin_t = ^cos_msin_t;
  cos_msin_t = record
    //
    cosine: float;
    minus_sine: float;
  end;

  {*
	Discrete Cosine Transform, Type IV
  }
  unaDCT_IV = class(unaObject)
  private
    dct_core_a: array[0..100 - 1] of float;
    //
    cos_msin_5: array[0..5 - 1] of cos_msin_t;      //* Not used since core_size = 10 */
    cos_msin_10: array[0..10] of cos_msin_t;
    cos_msin_20: array[0..20] of cos_msin_t;
    cos_msin_40: array[0..40] of cos_msin_t;
    cos_msin_80: array[0..80] of cos_msin_t;
    cos_msin_160: array[0..160] of cos_msin_t;
    cos_msin_320: array[0..320] of cos_msin_t;
    cos_msin_640: array[0..640] of cos_msin_t;  //* Used only for 640 point dct */
    //
    cos_msin_table: array[0..7] of pointer;
    //
    here_before3: int32;
    //
    procedure set_up_one_table(table: pcos_msin_t; length: long);
    procedure set_up_tables(dct_size: long);
  public
    constructor create();
    //
    procedure dct_type_iv(input, output: pFloat; dct_length: long);
  end;


  {*
	G.722.1 Coder
  }
  unaG7221Coder = class(unaObject)
  private
    dct: unaDCT_IV;
    mtl: unaMTLVector;
    //
    f_framesize,
    f_number_of_bits_per_frame,
    f_number_of_16bit_words_per_frame: int32;
    //
    out_words: tmax_frame;
    //
    region_size: int32;
    region_size_inverse: float;
    //
    num_rate_control_possibilities: int32;
    num_rate_control_bits: int32;
    //
    b0,b1,b2,b3: int32;
    //
    f_subStream: unaMemoryStream;
    f_subBuf: pointer;  // buffer for one chunk
    //
    f_numFrames: unsigned;
  protected
    {*
    }
    function init(sampleRate: int = 16000; bitrate: int = 24000): bool; virtual;
    {*
	Size of portion of data (frame) the coder is expecting to process at once.
	In bytes.
    }
    function chunkSize(): uint; virtual; abstract;
    {*
	Encodes/decodes data.

	@return number of full frames processed.
    }
    function process(ptr: pointer; len: uint): int; virtual; abstract;
    {*
	Called when new encoded/decoded frame is ready.
    }
    procedure notify(stream: pointer; sizeBytes: int); virtual;
  public
    {*
    }
    constructor create(sampleRate: int = 16000; bitrate: int = 24000);
    {*
    }
    destructor Destroy(); override;
    {*
	Opens the coder.
    }
    procedure open();
    {*
	Closes the coder.
    }
    procedure close();
    {*
	Sends more data to coder.

	@param data 16-bit samples for encoder or
	@param len size of buffer in bytes
	@return number of full frames processed in this call.
    }
    function write(data: pointer; len: uint): int;
    //
    {*
	Size of mono frame in samples.
    }
    property framesize: int32 read f_framesize;
    {*
	Size of frame in 16-bit words.
    }
    property number_of_16bit_words_per_frame: int32 read f_number_of_16bit_words_per_frame;
    {*
	Size of frame in bits.
    }
    property number_of_bits_per_frame: int32 read f_number_of_bits_per_frame;
  end;


  {*
	G.722.1 Decoder
  }
  unaG7221Decoder = class(unaG7221Coder)
  private
    old_samples1: array[0..MAX_DCT_SIZE shr 1 - 1] of float;
    window1: array[0..MAX_DCT_SIZE] of float;
    //
    here_before1: int32;
    here_before2: int32;
    //
    number_of_bits_left: int32;
    next_bit: int32;
    code_word: uint32;
    code_bit_count: int32;
    code_word_ptr: pUInt16;
    old_decoder_mlt_coefs: tmax_dct_sizef;
    //
    decoder_mlt_coefs: tmax_dct_sizef;
    float_out_samples: tmax_dct_sizef;
    output: tmax_dct_size;
    //
    procedure get_rand(var random_word: int32);
    //
    procedure rmlt_coefs_to_samples(coefs: pFloat; out_samples: pFloat; dct_size: int32);
    //
    procedure rate_adjust_categories(rate_control: int32; var decoder_power_categories: tmax_regions; const decoder_category_balances: tmax_rate_control);
    procedure decode_envelope(number_of_regions: int32; out decoder_region_standard_deviation: tmax_regionsf; out absolute_region_power_index: tmax_regions);
    procedure decode_vector_quantized_mlt_indices(number_of_regions: int32; const decoder_region_standard_deviation: tmax_regionsf; var decoder_power_categories: tmax_regions; out decoder_mlt_coefs: tmax_dct_sizef);
    //
    procedure GET_NEXT_BIT();
  protected
    {*
	Size of portion of data (frame) the coder is expecting to process at once.
	In bytes.
    }
    function chunkSize(): uint; override;
    {*
	Decodes data.
    }
    function process(ptr: pointer; len: uint): int; override;
    {*
	Internal.
    }
    procedure decoder(number_of_regions: int32; number_of_bits_per_frame: int32; bitstream: pUInt16; out decoder_mlt_coefs: tmax_dct_sizef; var frame_error_flag: int32);
    {*
	Decodes a mono frame(s). Calls notify() for each decoded frame.

	@return number of full frames produced.
    }
    function decode(inStream: pointer; inBytes: int): int;
  public
  end;


  {*
	G.722.1 Encoder
  }
  unaG7221Encoder = class(unaG7221Coder)
  private
    old_samples2: tmax_dct_sizef;
    window2: tmax_dct_sizef;
    here_before4: int32;
    //
    float_new_samples: tmax_dct_sizef;
    mlt_coefs: tmax_dct_sizef;
    //
    procedure samples_to_rmlt_coefs(new_samples: pFloat; coefs: pFloat; dct_size: int32);
    //
    function compute_region_powers(number_of_regions: int32; mlt_coefs: tmax_dct_sizef; out drp_num_bits: tmax_regions; out drp_code_bits: tmax_regions;
	 out absolute_region_power_index: tmax_regions): int32;
    //
    procedure vector_quantize_mlts(number_of_regions: int32; number_of_available_bits: int32; const mlt_coefs: tmax_dct_sizef; const absolute_region_power_index: tmax_regions;
	 var power_categories: tmax_regions; const category_balances: tmax_rate_control; out p_rate_control: int32; out region_mlt_bit_counts: tmax_regions; const region_mlt_bits: tmax_regions4);
    //
    function vector_huffman(category: int32; power_index: int32; raw_mlt_ptr: pFloat; word_ptr: pUInt32): int32;
  protected
    {*
	Size of portion of data (frame) the coder is expecting to process at once.
	In bytes.
    }
    function chunkSize(): uint; override;
    {*
	Encodes data.
    }
    function process(ptr: pointer; len: uint): int; override;
    {*
	Internal.
    }
    procedure encoder(number_of_regions: int32; number_of_available_bits: int32; const mlt_coefs: tmax_dct_sizef; out out_words: tmax_frame);
    {*
	Encodes a mono frame(s). Calls notify() for each encoded frame.

	@return number of full frames consumed.
    }
    function encode(inFrame: pInt16; inSamples: int): int;
  public
    //
  end;


implementation


uses
  Math, unaUtils;

{*****************************************************************
******************************************************************
**
**   G.722.1 Annex B - G.722.1 Floating point implementation
**   > Software Release 2.1 (2008-06)
**
**	Filename : common.c
**
**    © 2000 PictureTel Coporation
**          Andover, MA, USA
**
**	    All rights reserved.
**
******************************************************************
*****************************************************************}

//#include <stdio.h>
//#include <math.h>
//#include "defs.h"

//#include "huff_defs.h"
//#include "huff_tables.h"

const
  vector_dimension: array[0..NUM_CATEGORIES - 1] of int32 =  ( 2, 2, 2, 4, 4, 5, 5, 1);
  number_of_vectors: array[0..NUM_CATEGORIES - 1] of int32 = (10,10,10, 5, 5, 4, 4,20);
  //
  //* The last category isn't really coded with scalar quantization. */
  step_size: array[0..NUM_CATEGORIES - 1] of float 	= (0.3536, 0.5, 0.7071, 1.0, 1.4142, 2.0, 2.8284, 2.8284);
  max_bin: array[0..NUM_CATEGORIES - 1] of int32  	= (13, 9, 6, 4, 3, 2, 1, 1);
  dead_zone: array[0..NUM_CATEGORIES - 1] of float	= (0.3, 0.33, 0.36, 0.39, 0.42, 0.45, 0.5, 0.5);


{ unaMTLVector }

// --  --
constructor unaMTLVector.create();
begin
  mlt_based_coder_init();
  //
  inherited create();
end;


{****************************************************************************************
 Procedure/Function:  index_to_array

 Syntax:   number_of_non_zero = index_to_array(int index,
					       int array[MAX_VECTOR_DIMENSION],
					       int category)

		inputs:  int index
			 int category

		outputs: int array[MAX_VECTOR_DIMENSION] - used in decoder to access
							     mlt_quant_centroid table

			 int number_of_non_zero          - number of non zero elements
							     in the array

 Description:   Computes an array of sign bits with the length of the category vector
		Returns the number of sign bits and the array

****************************************************************************************}
function unaMTLVector.index_to_array(index: int32; out _array: tmax_vector; category: int32): int32;
var
  j,q,p,
  max_bin_plus_one,
  inverse_of_max_bin_plus_one: int32;
begin
  result := 0;
  p := index;
  max_bin_plus_one := max_bin[category] + 1;
  //
  inverse_of_max_bin_plus_one := max_bin_plus_one_inverse[category];
  //
  for j := vector_dimension[category] - 1 downto 0 do begin
    //
    //*    q = p/max_bin_plus_one; */
    //
    q := sshr((p * inverse_of_max_bin_plus_one), 15);
    _array[j] := p - q * max_bin_plus_one;
    p := q;
    //
    if (0 <> _array[j]) then
      inc(result);
  end;
end;

{****************************************************************************************
 Procedure/Function:  mlt_based_coder_init

 Syntax:        void mlt_based_coder_init()
		inputs:  none

		outputs: none

 Description:   Initializes region and category related stuff

****************************************************************************************}
procedure unaMTLVector.mlt_based_coder_init();
var
  i,
  category: int32;
{$IFDEF G722_DEUBUG }
  j, number_of_indices: int32;
{$ENDIF G722_DEUBUG }
begin
  for i := 0 to REGION_POWER_TABLE_SIZE - 1 do begin
    //
    region_power_table[i] :=
       Power(10.0, 0.10 * REGION_POWER_STEPSIZE_DB * (i - REGION_POWER_TABLE_NUM_NEGATIVES));
    //
    region_standard_deviation_table[i] := sqrt(region_power_table[i]);
    standard_deviation_inverse_table[i] := 1.0 / region_standard_deviation_table[i];
  end;
  //
  for i := 0 to REGION_POWER_TABLE_SIZE-2 do begin
    //
    region_power_table_boundary[i] :=
      Power(10.0, 0.10 * REGION_POWER_STEPSIZE_DB * (0.5 + (i - REGION_POWER_TABLE_NUM_NEGATIVES)));
  end;
  //
  //* Initialize category related stuff. */
  //
  for category := 0 to NUM_CATEGORIES - 1 do begin
    //
    //* Rounding up by 1.0 instead of 0.5 allows us to avoid rounding every time this is used. */
    //
    max_bin_plus_one_inverse[category] := trunc(32768 / (max_bin[category] + 1) + 1.0);
    //
{$IFDEF G722_DEUBUG }
    //
    //* Test division for all indices. */
    //
    number_of_indices := 1;
    for j := 0 to vector_dimension[category] - 1 do
      number_of_indices := number_of_indices * (max_bin[category] + 1);
    //
    for j := 0 to number_of_indices - 1 do begin
      //
      if (j/(max_bin[category]+1) != ((j*max_bin_plus_one_inverse[category]) >> 15))
	  printf("max_bin_plus_one_inverse ERROR!! %1d: %5d %3d\n",category,max_bin_plus_one_inverse[category],j);
    end;
{$ENDIF G722_DEUBUG }
    //
  end; // for category..
  //
  for category := 0 to NUM_CATEGORIES - 1 do
    step_size_inverse_table[category] := 1.0 / step_size[category];
end;

{****************************************************************************************
 Procedure/Function:  categorize

 Syntax:    void categorize(number_of_regions,
			    number_of_available_bits,
			    rms_index,
			    power_categories,
			    category_balances)

		  inputs:   number_of_regions
					    number_of_available_bits
			    rms_index[MAX_NUM_REGIONS]

		  outputs:  power_categories[MAX_NUM_REGIONS]
			    category_balances[MAX_NUM_RATE_CONTROL_POSSIBILITIES-1]

 Description: Computes a series of categorizations
****************************************************************************************}
procedure unaMTLVector.categorize(number_of_regions: int32; num_rate_control_possibilities: int32;
		number_of_available_bits: int32;
		const rms_index: tmax_regions;
		out power_categories: tmax_regions;
		out category_balances: tmax_rate_control);
var
  region,
  j,
  expected_number_of_code_bits,
  delta,
  offset,
  test_offset: int32;
  //
  max_rate_categories: tmax_regions;
  min_rate_categories: tmax_regions;
  temp_category_balances: array[0..2 * MAX_NUM_RATE_CONTROL_POSSIBILITIES - 1] of int32;
  //
  raw_max, raw_min,
  raw_max_index, raw_min_index,
  max_rate_pointer, min_rate_pointer,
  max, min,
  itemp0: int32;
begin
  {* At higher bit rates, there is an increase for most categories in average bit
     consumption per region. We compensate for this by pretending we have fewer
     available bits.
  *}
  if (number_of_regions <= 14) then begin
    //
    if (number_of_available_bits > 320) then
      number_of_available_bits := 320 + (sshr((number_of_available_bits - 320) * 5, 3));
  end;
  //
  offset := -32;
  delta := 32;
  repeat
    //
    test_offset := offset + delta;
    for region := 0 to number_of_regions - 1 do begin
      //
      j := (test_offset - rms_index[region]);
      if (0 > j) then
        j := 0
      else begin
	//
	j := j shr 1;
	if (j < 0) then j := 0;
	if (j > NUM_CATEGORIES - 1) then j := NUM_CATEGORIES - 1;
      end;
      //
      power_categories[region] := j;
    end;
    //
    expected_number_of_code_bits := 0;
    for region := 0 to number_of_regions - 1 do
      inc(expected_number_of_code_bits, expected_bits_table[power_categories[region]]);
    //
    if (expected_number_of_code_bits >= number_of_available_bits - 32) then
      offset := test_offset;
    //
    delta := sshr(delta, 1);
    //
  until (delta <= 0);
  //
  for region := 0 to number_of_regions - 1 do begin
    //
    j := (offset - rms_index[region]);
    if (0 > j) then
      j := 0
    else begin
      j := j shr 1;
      if (j < 0) then j := 0;
      if (j > NUM_CATEGORIES - 1) then j := NUM_CATEGORIES - 1;
    end;
    //
    power_categories[region] := j;
  end;
  //
  expected_number_of_code_bits := 0;
  for region := 0 to number_of_regions - 1 do
    inc(expected_number_of_code_bits, expected_bits_table[power_categories[region]]);
  //
  for region := 0 to number_of_regions - 1 do begin
    //
    max_rate_categories[region] := power_categories[region];
    min_rate_categories[region] := power_categories[region];
  end;
  //
  max := expected_number_of_code_bits;
  min := expected_number_of_code_bits;
  max_rate_pointer := num_rate_control_possibilities;
  min_rate_pointer := num_rate_control_possibilities;
  //
  for j := 0 to num_rate_control_possibilities - 2 do begin
    //
    if (max + min <= 2 * number_of_available_bits) then begin
      //
      raw_min := 99;
      //
      //* Search from lowest freq regions to highest for best region to reassign to
      //  a higher bit rate category. */
      //
      raw_min_index := 0;	// ??
      //
      for region := 0 to number_of_regions - 1 do begin
	//
	if (max_rate_categories[region] > 0) then begin
	  //
	  itemp0 := offset - rms_index[region] - 2 * max_rate_categories[region];
	  if (itemp0 < raw_min) then begin
	    //
	    raw_min := itemp0;
	    raw_min_index := region;
	  end;
	end;
      end;
      //
      dec(max_rate_pointer);
      temp_category_balances[max_rate_pointer] := raw_min_index;
      //
      dec(max, expected_bits_table[max_rate_categories[raw_min_index]]);
      if (0 < max_rate_categories[raw_min_index]) then begin
        //
        dec(max_rate_categories[raw_min_index]);
        inc(max, expected_bits_table[max_rate_categories[raw_min_index]]);
      end;
    end
    else begin
      //
      raw_max := -99;
      //
      //* Search from highest freq regions to lowest for best region to reassign to
      //	 a lower bit rate category. */
      //
      raw_max_index := 0;	// ??
      //
      for region := number_of_regions - 1 downto 0 do begin
	//
	if (min_rate_categories[region] < NUM_CATEGORIES-1) then begin
	  //
	  itemp0 := offset - rms_index[region] - 2 * min_rate_categories[region];
	  if (itemp0 > raw_max) then begin
	    //
	    raw_max := itemp0;
	    raw_max_index := region;
	  end;
	end;
      end;
      //
      temp_category_balances[min_rate_pointer] := raw_max_index;
      inc(min_rate_pointer);
      //
      dec(min, expected_bits_table[min_rate_categories[raw_max_index]]);
      inc(min_rate_categories[raw_max_index]);
      inc(min, expected_bits_table[min_rate_categories[raw_max_index]]);
    end;
  end; // for j ...
  //
  for region := 0 to number_of_regions - 1 do
    power_categories[region] := max_rate_categories[region];
  //
  for j := 0 to num_rate_control_possibilities - 2 do begin
    //
    category_balances[j] := temp_category_balances[max_rate_pointer];
    inc(max_rate_pointer);
  end;
end;



{ unaDCT_IV }

constructor unaDCT_IV.create();
begin
  cos_msin_table[0] := @cos_msin_5;
  cos_msin_table[1] := @cos_msin_10;
  cos_msin_table[2] := @cos_msin_20;
  cos_msin_table[3] := @cos_msin_40;
  cos_msin_table[4] := @cos_msin_80;
  cos_msin_table[5] := @cos_msin_160;
  cos_msin_table[6] := @cos_msin_320;
  cos_msin_table[7] := @cos_msin_640;
  //
  inherited create();
end;

{*****************************************************************
******************************************************************
**
**   G.722.1 Annex B - G.722.1 Floating point implementation
**   > Software Release 2.1 (2008-06)
**
**	Filename : dct4.c
**
**   © 2000 PictureTel Coporation
**          Andover, MA, USA
**
**	    All rights reserved.
**
******************************************************************
*****************************************************************}

{*********************************************************************************
* DCT_TYPE_IV	Discrete Cosine Transform, Type IV
*
* The basis functions are
*
*	 cos(PI*(t+0.5)*(k+0.5)/block_length)
*
* for time t and basis function number k.  Due to the symmetry of the expression
* in t and k, it is clear that the forward and inverse transforms are the same.
*
*********************************************************************************}

{*********************************************************************************
 Include files
*********************************************************************************}
//#include <stdio.h>
//#include <math.h>
//#include "defs.h"

{*********************************************************************************
 Procedure/Function:  set_up_one_table

 Syntax:       static void set_up_one_table (table, length)
	       cos_msin_t	table[];
	       long		length;

 Description:  SET_UP_ONE_TABLE	Set Up One Table of Cosine and Minus Sine Values

*********************************************************************************}
procedure unaDCT_IV.set_up_one_table(table: pcos_msin_t; length: long);
var
  angle, scale: double;
  index: int32;
begin
  scale := PI / (4 * length);
  for index := 0 to length - 1 do begin
    //
    angle := scale * (index + 0.5);
    table.cosine     := cos(angle);
    table.minus_sine := -sin(angle);
    inc(table);
  end;
end;


{*********************************************************************************
 Procedure/Function:  set_up_table s

 Syntax:       static void set_up_tables (long dct_size)

 Description:  Set Up Tables of Cosine and Minus Sine Values

*********************************************************************************}
procedure unaDCT_IV.set_up_tables(dct_size: long);
var
  length_log: int32;
  i, k: int32;
  scale: double;
begin
  scale := sqrt(2.0 / dct_size);
  //
  if (dct_size <= 0) then begin
    //
    // printf("wrong dct size"), exit(1);
  end
  else begin
    //
    length_log := 0;
    //
    while (0 = (dct_size and 1)) do begin
      //
      inc(length_log);
      dct_size := dct_size shr 1;
    end;
    //
    for k := 0 to 10 - 1 do begin
      //
      for i := 0 to 10 - 1 do
	dct_core_a[10 * k + i] := cos(PI * (k + 0.5) * (i + 0.5) / 10.0) * scale;
    end;
    //
    for i := 0 to length_log do
      set_up_one_table(cos_msin_table[i], dct_size shl i);
  end;
end;

{*********************************************************************************
 Procedure/Function:  dct_type_iv

 Syntax:       dct_type_iv (input, output, dct_length)
	       float	input[], output[];
	       long	dct_length;

 Description:  Discrete Cosine Transform, Type IV

*********************************************************************************}
procedure unaDCT_IV.dct_type_iv (
     input, output: pFloat;
     dct_length: long);
var
  buffer_a, buffer_b, buffer_c: tmax_dct_sizef;
  in_ptr, in_ptr_low, in_ptr_high, next_in_base: pFloat;
  out_ptr_low, out_ptr_high, next_out_base: pFloat;
  out_buffer, in_buffer, buffer_swap: pFloat;
  in_val_low, in_val_high: float;
  fptr0, fptr1, fptr2: pFloat;
  cos_even, cos_odd, msin_even, msin_odd: float;
  set_span, set_count, set_count_log, pairs_left, sets_left: int32;
  table_ptr_ptr: ^pcos_msin_t;
  cos_msin_ptr: pcos_msin_t;
  i, k: int32;
  sum: float;
  dct_length_log: int32;
  core_size: int32;
begin
  //*++++++++++++++++++++++++++++++++++++++++++++++++++*/
  //* Set up the tables if this is the first time here */
  //*++++++++++++++++++++++++++++++++++++++++++++++++++*/
  //
  if (0 = here_before3) then begin
    //
    set_up_tables(dct_length);
    here_before3 := 1;
  end;
  //
  dct_length_log := 1;
  core_size := dct_length;
  //
  while (0 = (core_size and 1)) do begin
    //
    inc(dct_length_log);
    core_size := sshr(core_size, 1);
  end;
  //
  core_size := sshl(core_size, 1);
  dec(dct_length_log);
  //
  //*++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
  //* Do the sum/difference butterflies, the first part of */
  //* converting one N-point transform into N/2 two-point  */
  //* transforms, where N = 1 << dct_length_log.           */
  //*++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
  //
  in_buffer  := input;
  out_buffer := pFloat(@buffer_a);
  for set_count_log := 0 to dct_length_log - 2 do begin
    //
    //*===========================================================*/
    //* Initialization for the loop over sets at the current size */
    //*===========================================================*/
    //
    set_span := dct_length shr set_count_log;
    //
    set_count     := 1 shl set_count_log;
    in_ptr        := in_buffer;
    next_out_base := out_buffer;
    //
    //*=====================================*/
    //* Loop over all the sets of this size */
    //*=====================================*/
    //
    for sets_left := set_count downto 0 + 1 do begin
      //
      //*||||||||||||||||||||||||||||||||||||||||||||*/
      //* Set up output pointers for the current set */
      //*||||||||||||||||||||||||||||||||||||||||||||*/
      //
      out_ptr_low    := next_out_base;
      inc(next_out_base, set_span);
      out_ptr_high   := next_out_base;
      //
      //*||||||||||||||||||||||||||||||||||||||||||||||||||*/
      //* Loop over all the butterflies in the current set */
      //*||||||||||||||||||||||||||||||||||||||||||||||||||*/
      //
      repeat
	//
	in_val_low      := in_ptr^;
	inc(in_ptr);
	in_val_high     := in_ptr^;
	inc(in_ptr);
	//
	out_ptr_low^	:= in_val_low + in_val_high;
	inc(out_ptr_low);
	dec(out_ptr_high);
	out_ptr_high^ := in_val_low - in_val_high;
	//
      until (IntPtr(out_ptr_low) >= IntPtr(out_ptr_high));
      //
    end; //* End of loop over sets of the current size */
    //
    //*============================================================*/
    //* Decide which buffers to use as input and output next time. */
    //* Except for the first time (when the input buffer is the    */
    //* subroutine input) we just alternate the local buffers.     */
    //*============================================================*/
    //
    in_buffer := out_buffer;
    if (pointer(out_buffer) = @buffer_a) then
      out_buffer := pFloat(@buffer_b)
    else
      out_buffer := pFloat(@buffer_a);
    //
  end; //* End of loop over set sizes */
  //
  //*+++++++++++++++++++++++++++++++++++++*/
  //* Do dct_size/10 ten-point transforms */
  //*+++++++++++++++++++++++++++++++++++++*/
  //
  fptr0 := in_buffer;
  buffer_swap := pFloat(@buffer_c);
  //
  for pairs_left := 1 shl (dct_length_log - 1) downto 0 + 1 do begin
    //
    fptr2 := pFloat(@dct_core_a);
    for k := 0 to core_size - 1 do begin
      //
      fptr1 := fptr0;
      sum := 0;
      for i := 0 to core_size - 1 do begin
	//
	sum := sum + fptr1^ * fptr2^;
	inc(fptr1);
	inc(fptr2);
      end;
      //
      pFloatArray(buffer_swap)[k] := sum;
    end;
    //
    inc(fptr0, core_size);
    inc(buffer_swap, core_size);
  end;
  //
  //memcpy(in_buffer, buffer_c, dct_length*sizeof(float));
  move(buffer_c, in_buffer^, dct_length * sizeof(float));
  //
  table_ptr_ptr := pointer(@cos_msin_table);
  //
  //*++++++++++++++++++++++++++++++*/
  //* Perform rotation butterflies */
  //*++++++++++++++++++++++++++++++*/
  //
  for set_count_log := dct_length_log - 2 downto 0 do begin
    //
    //*===========================================================*/
    //* Initialization for the loop over sets at the current size */
    //*===========================================================*/
    //
    set_span := sshr(dct_length, set_count_log);
    //
    set_count := 1 shl set_count_log;
    next_in_base := in_buffer;
    if (0 = set_count_log) then
      next_out_base := output
    else
      next_out_base := out_buffer;
    //
    inc(table_ptr_ptr);
    //
    //*=====================================*/
    //* Loop over all the sets of this size */
    //*=====================================*/
    //
    for sets_left := set_count downto 0 + 1 do begin
      //
      //*|||||||||||||||||||||||||||||||||||||||||*/
      //* Set up the pointers for the current set */
      //*|||||||||||||||||||||||||||||||||||||||||*/
      //
      in_ptr_low     := next_in_base;
      in_ptr_high    := @pFloatArray(in_ptr_low)[set_span shr 1];
      inc(next_in_base, set_span);
      out_ptr_low    := next_out_base;
      inc(next_out_base, set_span);
      out_ptr_high   := next_out_base;
      cos_msin_ptr   := table_ptr_ptr^;
      //
      //*||||||||||||||||||||||||||||||||||||||||||||||||||||||*/
      //* Loop over all the butterfly pairs in the current set */
      //*||||||||||||||||||||||||||||||||||||||||||||||||||||||*/
      //
      repeat
	//
	cos_even      := cos_msin_ptr.cosine;
	msin_even     := cos_msin_ptr.minus_sine;
	inc(cos_msin_ptr);
	out_ptr_low^  := cos_even * in_ptr_low^ - msin_even * in_ptr_high^;
	inc(out_ptr_low);
	dec(out_ptr_high);
	out_ptr_high^ := msin_even * in_ptr_low^ + cos_even * in_ptr_high^;
	inc(in_ptr_low);
	inc(in_ptr_high);
	//
	cos_odd       := cos_msin_ptr.cosine;
	msin_odd      := cos_msin_ptr.minus_sine;
	inc(cos_msin_ptr);
	out_ptr_low^  := cos_odd * in_ptr_low^ + msin_odd * in_ptr_high^;
	inc(out_ptr_low);
	dec(out_ptr_high);
	out_ptr_high^ := msin_odd * in_ptr_low^ - cos_odd * in_ptr_high^;
	inc(in_ptr_low);
	inc(in_ptr_high);
	//
      until (IntPtr(out_ptr_low) >= IntPtr(out_ptr_high));
      //
    end; //* End of loop over sets of the current size */
    //
    //*=============================================*/
    //* Swap input and output buffers for next time */
    //*=============================================*/
    //
    buffer_swap := in_buffer;
    in_buffer   := out_buffer;
    out_buffer  := buffer_swap;
  end;
end;


//=======================================   ====================================
//======================================= CODER ====================================
//=======================================   ====================================

{ unaG7221Coder }

// --  --
procedure unaG7221Coder.close();
begin
  f_subStream.clear();
end;

// --  --
constructor unaG7221Coder.create(sampleRate, bitrate: int);
begin
  //*  region_size = (BLOCK_SIZE * 0.875)/NUM_REGIONS; */
  //
  region_size := 20;
  region_size_inverse := 1.0 / region_size;
  //
  dct := unaDCT_IV.create();
  mtl := unaMTLVector.create();
  //
  init(sampleRate, bitrate);
  //
  f_subStream := unaMemoryStream.create();
  //
  inherited create();
end;

// --  --
destructor unaG7221Coder.Destroy();
begin
  inherited;
  //
  freeAndNil(dct);
  freeAndNil(mtl);
  //
  freeAndNil(f_subStream);
  mrealloc(f_subBuf);
end;

// --  --
function unaG7221Coder.init(sampleRate, bitrate: int): bool;
var
  bit_rate,
  sample_rate: int;
begin
  sample_rate := sampleRate;
  bit_rate := bitrate;
  //
  if ((bit_rate < 8000) or (bit_rate > 48000) or
      ((bit_rate div 800) * 800 <> bit_rate)) then begin
    //
    result := false;
  end
  else begin
    //
    f_framesize := sample_rate div 50;
    if (MAX_DCT_SIZE >= f_framesize) then begin
      //
      f_number_of_bits_per_frame := bit_rate div 50;
      f_number_of_16bit_words_per_frame := number_of_bits_per_frame shr 4;
      result := true;
    end
    else
      result := false;
  end;
  //
  if (result) then
    f_subBuf := malloc(chunkSize());
  //
  if (nil <> f_subStream) then
    f_subStream.clear();
end;

// --  --
procedure unaG7221Coder.notify(stream: pointer; sizeBytes: int);
begin
  // override to get data
  inc(f_numFrames);
end;

// --  --
procedure unaG7221Coder.open();
begin
  f_subStream.clear();
end;

// --  --
function unaG7221Coder.write(data: pointer; len: uint): int;
var
  nc: int;
begin
  result := 0;
  //
  if (0 < chunkSize()) then begin
    //
    // something has left unprocessed from previous write?
    if (0 < f_subStream.getAvailableSize()) then begin
      //
      f_subStream.write(data, len);
      len := 0;
    end;
    //
    // process full chunks, one by one
    while (chunkSize() <= uint(f_subStream.getAvailableSize())) do begin
      //
      f_subStream.read(f_subBuf, chunkSize());
      inc(result, process(f_subBuf, chunkSize()));
    end;
    //
    // or maybe nothing has left, and we have just enough data for one or more chunks?
    while (chunkSize() <= len) do begin
      //
      nc := chunkSize() * (len div chunkSize());
      inc(result, process(data, nc));
      //
      dec(len, nc);
      inc(pByte(data), nc);
    end;
    //
    // finally, write leftovers to subStream
    if (0 < len) then
      f_subStream.write(data, len);
  end;
end;


//=======================================   ====================================
//======================================= DECODE ====================================
//=======================================   ====================================


{ unaG7221Decoder }

{*****************************************************************
******************************************************************
**
**   G.722.1 Annex B - G.722.1 Floating point implementation
**   > Software Release 2.1 (2008-06)
**
**	Filename : rmlt_coefs_to_samples.c
**
**   © 2000 PictureTel Coporation
**          Andover, MA, USA
**
**	    All rights reserved.
**
******************************************************************
*****************************************************************}

{*********************************************************************************
* RMLT_COEFS_TO_SAMPLES		Convert Reversed MLT (Modulated Lapped Transform)
*				Coefficients to Samples
*
*     The "Reversed MLT" is an overlapped block transform which uses even symmetry
* on the left, odd symmetry on the right and a Type IV DCT as the block transform.
* It is thus similar to a MLT which uses odd symmetry on the left, even symmetry
* on the right and a Type IV DST as the block transform.  In fact, it is equivalent
* to reversing the order of the samples, performing an MLT and then negating all
* the even-numbered coefficients.
*
*********************************************************************************}

//************************************************************************************
// Include files
//*************************************************************************************/

//#include <stdio.h>
//#include <math.h>
//#include "defs.h"

{***************************************************************************
 Procedure/Function:  rmlt_samples_to_coefs

 Syntax:       void rmlt_coefs_to_samples(coefs,
			   out_samples,
			   dct_size)

				float *coefs;
				float *out_samples;
				int dct_size;

			inputs:    float *coefs
		       int dct_size

	    outputs:   float *out_samples

 Description:    Converts the mlt_coefs to samples

***************************************************************************}
procedure unaG7221Decoder.rmlt_coefs_to_samples(
  coefs: pFloat;
  out_samples: pFloat;
  dct_size: int32);
var
  //extern void dct_type_iv(float *, float *, long);
  sum: float;
  index, vals_left: int32;
  angle: double;
  new_samples: tmax_dct_sizef;
  new_ptr, old_ptr: pFloat;
  win_new, win_old: pFloat;
  out_ptr: pFloat;
  half_dct_size: int32;
begin
  half_dct_size := dct_size shr 1;
  //
  //*++++++++++++++++++++++++++++++++++++++*/
  //* Set up some data the first time here */
  //*++++++++++++++++++++++++++++++++++++++*/
  //
  if (0 = here_before2) then begin
    //
    for index := 0 to dct_size - 1 do begin
      //
      angle := (PI / 2.0) * (index + 0.5) / dct_size;
      //
      //* This changed when ENCODER_SCALE_FACTOR changed from 20853.0 to 18318.0. */
      //*       window[index] = 2.20895 * sin(angle); */
      //*       window[index] = (2.20895 * 129.5704536) * sin(angle); */
      //*       window[index] = (2.20895 * 129.6) * sin(angle); */
      window1[index] := sin(angle);
    end;
    //
    for index := 0 to half_dct_size - 1 do
      old_samples1[index] := 0.0;
    //
    here_before2 := 1;
  end;
  //
  //*+++++++++++++++++++++++++++++++++++++++++++++++++++++*/
  //* Perform a Type IV (inverse) DCT on the coefficients */
  //*+++++++++++++++++++++++++++++++++++++++++++++++++++++*/
  //
  dct.dct_type_iv(coefs, pFloat(@new_samples), dct_size);
  //
  //*++++++++++++++++++++++++++++++++++++++++++++*/
  //* Get the first half of the windowed samples */
  //*++++++++++++++++++++++++++++++++++++++++++++*/
  //
  out_ptr := out_samples;
  win_new := pFloat(@window1);
  win_old := pFloat(@window1[dct_size]);
  old_ptr := pFloat(@old_samples1);
  new_ptr := pFloat(@new_samples[half_dct_size]);
  //
  for vals_left := half_dct_size downto 0 + 1 do begin
    //
    dec(new_ptr);
    sum := win_new^ * new_ptr^;
    inc(win_new);
    //
    dec(win_old);
    sum := sum + win_old^ * old_ptr^;
    inc(old_ptr);
    //
    out_ptr^ := sum;
    inc(out_ptr);
  end;
  //
  //*+++++++++++++++++++++++++++++++++++++++++++++*/
  //* Get the second half of the windowed samples */
  //*+++++++++++++++++++++++++++++++++++++++++++++*/
  //
  for vals_left := half_dct_size downto 0 + 1 do begin
    //
    sum := win_new^ * new_ptr^;
    inc(new_ptr);
    inc(win_new);
    //
    dec(win_old);
    dec(old_ptr);
    sum := sum - win_old^ * old_ptr^;
    //
    out_ptr^ := sum;
    inc(out_ptr);
  end;
  //
  //*+++++++++++++++++++++++++++++++++++++++++++++++*/
  //* Save the second half of the new samples for   */
  //* next time, when they will be the old samples. */
  //*+++++++++++++++++++++++++++++++++++++++++++++++*/
  //
  new_ptr := pFloat(@new_samples[half_dct_size]);
  old_ptr := pFloat(@old_samples1);
  for vals_left := half_dct_size downto 0 + 1 do begin
    //
    old_ptr^ := new_ptr^;
    inc(old_ptr);
    inc(new_ptr);
  end;
end;


{*****************************************************************
******************************************************************
**
**   G.722.1 Annex B - G.722.1 Floating point implementation
**   > Software Release 2.1 (2008-06)
**
**	Filename : decoder.c
**
**   © 2000 PictureTel Coporation
**          Andover, MA, USA
**
**	    All rights reserved.
**
******************************************************************
*****************************************************************}

{*****************************************************************
  Filename:   decoder.c
  Original Author:
  Creation Date:

  Purpose:         Contains files used to implement
		   the G.722.1 decoder
******************************************************************}

{******************************************************************
 Include files
*******************************************************************}

//#include <stdio.h>
//#include <math.h>
//#include "defs.h"
//#include "huff_defs.h"

const
  NOISE_SCALE_FACTOR	= 22.0;

{// inline //}
procedure unaG7221Decoder.GET_NEXT_BIT();
begin
  if (0 = code_bit_count) then begin
    //
    code_word := code_word_ptr^;
    inc(code_word_ptr);
    code_bit_count := 16;
  end;
  //
  dec(code_bit_count);
  //
  next_bit := (sshr(code_word, code_bit_count) and 1);
end;

// --  --
function unaG7221Decoder.chunkSize(): uint;
begin
  result := number_of_16bit_words_per_frame shl 1;
end;

// --  --
function unaG7221Decoder.decode(inStream: pointer; inBytes: int): int;
var
  frame_error_flag: int32;
  ftemp0: float;
  i: int32;
begin
  frame_error_flag := 0;
  result := 0;
  //
  //* Read first frame of samples from disk. */
  while (inBytes >= number_of_16bit_words_per_frame shl 1) do begin
    //
    decoder(
      14, //number_of_regions,
      number_of_bits_per_frame,
      pUInt16(inStream),
      decoder_mlt_coefs,
      frame_error_flag);
    //
    inc(pByte(inStream), number_of_16bit_words_per_frame shl 1);
    dec(inBytes, number_of_16bit_words_per_frame shl 1);
    //
    if (0 = frame_error_flag) then begin
      //
      rmlt_coefs_to_samples(pFloat(@decoder_mlt_coefs), pFloat(@float_out_samples), framesize);
      //
      for i := 0 to framesize - 1 do begin
	//
	ftemp0 := float_out_samples[i];
	if (ftemp0 >= 0.0) then begin
	  //
	  if (ftemp0 < 32767.0) then
	    output[i] := trunc(ftemp0 + 0.5)
	  else
	    output[i] := 32767;
	end
	else begin
	  //
	  if (ftemp0 > -32768.0) then
	    output[i] := trunc(ftemp0 - 0.5)
	  else
	    output[i] := -32768;
	end;
      end;
      //
      //* For ITU testing and off the 2 lsbs. */
      for i := 0 to framesize - 1 do
        output[i] := int16(uint(output[i]) and $fffc);
      //
      notify(@output, framesize shl 1);
      //
      inc(result);
    end
    else
      result := result;
  end;
end;


{***************************************************************************
 Procedure/Function:  decoder

 Syntax:     void decoder(  number_of_regions,
							number_of_bits_per_frame,
							bitstream,
							decoder_mlt_coefs,
							frame_error_flag)

							int number_of_regions;
							int number_of_bits_per_frame;
							short int bitstream[];
							float decoder_mlt_coefs[MAX_DCT_SIZE];
							int frame_error_flag;

	      inputs:    int number_of_regions
			 int number_of_bits_per_frame
						 int frame_error_flag

	      outputs:   float *decoder_mlt_coefs[],
			 short int bitstream[]

 Description:

***************************************************************************}
procedure unaG7221Decoder.decoder(
     number_of_regions: int32;
     number_of_bits_per_frame: int32;
     bitstream: pUInt16;
     out decoder_mlt_coefs: tmax_dct_sizef;
     var frame_error_flag: int32);
var
//  extern void categorize(int, int, int[], int[], int[]);
  absolute_region_power_index: tmax_regions;
  decoder_power_categories: tmax_regions;
  decoder_category_balances: tmax_rate_control;
  rate_control: int32;
  //
  decoder_region_standard_deviation: tmax_regionsf;
  number_of_coefs,
  number_of_valid_coefs: int32;
  //
  i: int32;
  region: int32;
begin
  number_of_valid_coefs := number_of_regions * region_size;
  //
  if (number_of_regions <= 14) then
    number_of_coefs := 320
  else
    number_of_coefs := 0;	// ??
  //
  if (0 = frame_error_flag) then begin
    //
    code_word_ptr := bitstream;
    code_bit_count := 0;
    //
    if (number_of_regions <= 14) then begin
      //
      num_rate_control_bits := 4;
      num_rate_control_possibilities := 16;
    end;
    //
    number_of_bits_left := number_of_bits_per_frame;
    //
    decode_envelope(number_of_regions,
		    decoder_region_standard_deviation,
		    absolute_region_power_index);
    //{
    rate_control := 0;
    for i := 0 to num_rate_control_bits - 1 do begin
      //
      GET_NEXT_BIT();
      rate_control := sshl(rate_control, 1);
      inc(rate_control, next_bit);
    end;
    //}
    dec(number_of_bits_left, num_rate_control_bits);
    //
    mtl.categorize(number_of_regions, num_rate_control_possibilities,
	       number_of_bits_left,
	       absolute_region_power_index,
	       decoder_power_categories,
	       decoder_category_balances);
    //
    rate_adjust_categories(rate_control,
			   decoder_power_categories,
			   decoder_category_balances);
    //
    decode_vector_quantized_mlt_indices(number_of_regions,
					decoder_region_standard_deviation,
					decoder_power_categories,
					decoder_mlt_coefs);
    //
    //* Test for bit stream errors. */
    //
    if (number_of_bits_left > 0) then begin
      //{
      for i := 0 to number_of_bits_left - 1 do begin
	//
	GET_NEXT_BIT();
	if (0 = next_bit) then frame_error_flag := 1;
      end;
      //}
    end
    else begin
      //
      if (rate_control < num_rate_control_possibilities - 1) then begin
	//
	if (number_of_bits_left < 0) then
	  frame_error_flag := frame_error_flag or 2;
      end;
    end;
    //{
    for region := 0 to number_of_regions - 1 do begin
      //
      if ((absolute_region_power_index[region] + ESF_ADJUSTMENT_TO_RMS_INDEX > 31) or
	  (absolute_region_power_index[region] + ESF_ADJUSTMENT_TO_RMS_INDEX < -8)) then
	frame_error_flag := frame_error_flag or 4;
    end;
    //}
  end; // if (0 == frame_error_flag)
  //
  //* If both the current and previous frames are errored,
  //  set the mlt coefficients to 0. If only the current frame
  //  is errored, then repeat the previous frame's mlt coefficients. */
  //{
  if (0 <> frame_error_flag) then begin
    //
    here_before1 := 0;
    //
    for i := 0 to number_of_valid_coefs - 1 do
      decoder_mlt_coefs[i] := old_decoder_mlt_coefs[i];
    //
    for i := 0 to number_of_valid_coefs - 1 do
      old_decoder_mlt_coefs[i] := 0;
  end
  else begin
    //
    //* Store in case next frame is errored. */
    //
    for i := 0 to number_of_valid_coefs - 1 do
      old_decoder_mlt_coefs[i] := decoder_mlt_coefs[i];
  end;
  //}
  //* Zero out the upper 1/8 of the spectrum. */
  //{
  for i := number_of_valid_coefs to number_of_coefs - 1 do
    decoder_mlt_coefs[i] := 0;
  //}
end;


{***************************************************************************
 Procedure/Function:  decode_envelope

 Syntax:   void decode_envelope(number_of_regions,
								decoder_region_standard_deviation,
								absolute_region_power_index)
								int number_of_regions;
								float decoder_region_standard_deviation[MAX_NUM_REGIONS];
								int absolute_region_power_index[MAX_NUM_REGIONS];


	      inputs:   int int number_of_regions

	      outputs:  float decoder_region_standard_deviation[MAX_NUM_REGIONS];
						int absolute_region_power_index[MAX_NUM_REGIONS];

 Description:  Recover differential_region_power_index from code bits

 Design Notes:

***************************************************************************}

{void decode_envelope(number_of_regions,
		     decoder_region_standard_deviation,
		     absolute_region_power_index)
     int number_of_regions;
     float decoder_region_standard_deviation[MAX_NUM_REGIONS];
     int absolute_region_power_index[MAX_NUM_REGIONS];}
procedure unaG7221Decoder.decode_envelope(
	number_of_regions: int32;
	out decoder_region_standard_deviation: tmax_regionsf;
	out absolute_region_power_index: tmax_regions
	);
var
  region,
  i,
  index: int32;
  differential_region_power_index: tmax_regions;
begin
  //* Recover differential_region_power_index[] from code_bits[]. */
  index := 0;
  for i := 0 to 5 - 1 do begin
    //
    GET_NEXT_BIT();
    index := sshl(index, 1);
    inc(index, next_bit);
  end;
  //
  //* ESF_ADJUSTMENT_TO_RMS_INDEX compensates for the current (9/30/96)
  //  IMLT being scaled to high by the ninth power of sqrt(2). */
  //
  differential_region_power_index[0] := index - ESF_ADJUSTMENT_TO_RMS_INDEX;
  dec(number_of_bits_left, 5);
  //
  for region := 1 to number_of_regions - 1 do begin
    //
    index := 0;
    repeat
      //
      GET_NEXT_BIT();
      if (0 = next_bit) then
	index := differential_region_power_decoder_tree[region][index][0]
      else
	index := differential_region_power_decoder_tree[region][index][1];
      //
      dec(number_of_bits_left);
    until (index <= 0);
    //
    differential_region_power_index[region] := -index;
  end;
  //
  //* Reconstruct absolute_region_power_index[] from differential_region_power_index[]. */
  //
  absolute_region_power_index[0] := differential_region_power_index[0];
  //
  for region := 1 to number_of_regions - 1 do begin
    //
    i := absolute_region_power_index[region - 1] + differential_region_power_index[region] + DRP_DIFF_MIN;
    if (i < -REGION_POWER_TABLE_NUM_NEGATIVES) then
      i := -REGION_POWER_TABLE_NUM_NEGATIVES;
    //
    if (i + REGION_POWER_TABLE_NUM_NEGATIVES > high(mtl.region_standard_deviation_table)) then
      i := high(mtl.region_standard_deviation_table) - REGION_POWER_TABLE_NUM_NEGATIVES;
    //
    absolute_region_power_index[region] := i;
  end;
  //
  //* Reconstruct decoder_region_standard_deviation[] from absolute_region_power_index[]. */
  //
  for region := 0 to number_of_regions -1  do begin
    //
    i := absolute_region_power_index[region] + REGION_POWER_TABLE_NUM_NEGATIVES;
    decoder_region_standard_deviation[region] := mtl.region_standard_deviation_table[i];
  end;
end;

{***************************************************************************
 Procedure/Function:  rate_adjust_categories

 Syntax:			void rate_adjust_categories(rate_control,
												decoder_power_categories,
												decoder_category_balances)
												int rate_control;
												int decoder_power_categories[MAX_NUM_REGIONS];
												int decoder_category_balances[MAX_NUM_RATE_CONTROL_POSSIBILITIES-1];


	       inputs:    int rate_control,
			  int *decoder_power_categories,
			  int *decoder_category_balances

	       outputs:   int rate_control,
			  int *decoder_power_categories,

 Description:     Adjust the power categories based on the categorization control

***************************************************************************}
procedure unaG7221Decoder.rate_adjust_categories(
		rate_control: int32;
		var decoder_power_categories: tmax_regions;
		const decoder_category_balances: tmax_rate_control);
var
  i,
  region: int32;
begin
  i := 0;
  while (rate_control > 0) do begin
    //
    region := decoder_category_balances[i];
    inc(i);
    inc(decoder_power_categories[region]);
    dec(rate_control);
  end;
end;

//* ************************************************************************************ */
//* ************************************************************************************ */

// -- inline -- //
procedure unaG7221Decoder.get_rand(var random_word: int32);
begin
  random_word := int32(int64(b0) + int64(b3));
  if (0 <> (random_word and $8000)) then inc(random_word);
  b3 := b2;
  b2 := b1;
  b1 := b0;
  b0 := random_word;
  //
  if (0 > random_word) then
    random_word := random_word;
end;

// --  --
function unaG7221Decoder.process(ptr: pointer; len: uint): int;
begin
  result := decode(ptr, int(len));
end;

{***************************************************************************
 Procedure/Function:   decode_vector_quantized_mlt_indices

 Syntax:  void decode_vector_quantized_mlt_indices(number_of_regions,
							decoder_region_standard_deviation,
							decoder_power_categories,
							decoder_mlt_coefs)

							int number_of_regions;
							float decoder_region_standard_deviation[MAX_NUM_REGIONS];
							int decoder_power_categories[MAX_NUM_REGIONS];
							float decoder_mlt_coefs[MAX_DCT_SIZE];

			 inputs:   int    number_of_regions
		       float  *decoder_region_standard_deviation
		       int    *decoder_power_categories

	     outputs:  float  decoder_mlt_coefs[MAX_DCT_SIZE]


 Description:

***************************************************************************}
const
  noise_fill_factor_cat5: array[0..19] of float = (0.70711, 0.6179, 0.5005, 0.3220,
					       0.17678, 0.17678, 0.17678, 0.17678,
					       0.17678, 0.17678, 0.17678, 0.17678,
					       0.17678, 0.17678, 0.17678, 0.17678,
					       0.17678, 0.17678, 0.17678, 0.17678);

  noise_fill_factor_cat6: array[0..19] of float = (0.70711, 0.5686, 0.3563, 0.25,
					       0.25, 0.25, 0.25, 0.25,
					       0.25, 0.25, 0.25, 0.25,
					       0.25, 0.25, 0.25, 0.25,
					       0.25, 0.25, 0.25, 0.25);

//
procedure unaG7221Decoder.decode_vector_quantized_mlt_indices(
		number_of_regions: int32;
		const decoder_region_standard_deviation: tmax_regionsf;
		var decoder_power_categories: tmax_regions;
		out decoder_mlt_coefs: tmax_dct_sizef);
var
  decoder_mlt_ptr: pFloat;
  standard_deviation,
  decoder_mlt_value,
  temp1,
  noifillpos,
  noifillneg: float;
  //
  region,
  category,
  j,n: int32;
  k: tmax_vector;
  vec_dim,
  num_vecs,
  index, signs_index,
  bit,
  num_sign_bits,
//  num_bits,
  ran_out_of_bits_flag: int32;
  decoder_table_ptr: pInt32;
  //
  random_word: int32;
begin
  if (0 = here_before1) then begin
    //
    here_before1 := 1;
    b0 := 1;
    b1 := 1;
    b2 := 1;
    b3 := 1;
  end;
  //
  bit := 0;
  //
  signs_index := 0;
  ran_out_of_bits_flag := 0;
  //
  for region := 0 to number_of_regions - 1 do begin
    //
    category := decoder_power_categories[region];
    decoder_mlt_ptr := @decoder_mlt_coefs[region * region_size];
    standard_deviation := decoder_region_standard_deviation[region];
    if (category < NUM_CATEGORIES - 1) then begin
      //
      decoder_table_ptr := table_of_decoder_tables[category];
      vec_dim := vector_dimension[category];
      num_vecs := number_of_vectors[category];
      //
      for n := 0 to num_vecs - 1 do begin
	//
	//num_bits := 0;
	index := 0;
	//
	repeat
	  //
	  if (number_of_bits_left <= 0) then begin
	    //
	    ran_out_of_bits_flag := 1;
	    break;
	  end;
	  //
	  GET_NEXT_BIT();
	  if (0 = next_bit) then
	    index := pInt32Array(decoder_table_ptr)[2*index]
	  else
	    index := pInt32Array(decoder_table_ptr)[2*index + 1];
	  //
	  dec(number_of_bits_left);
	  //
	until (index <= 0);
	//
	if (1 = ran_out_of_bits_flag) then
	  break;
	//
	index := -index;
	num_sign_bits := mtl.index_to_array(index, k, category);
	//
	if (number_of_bits_left >= num_sign_bits) then begin
	  //
	  if (0 <> num_sign_bits) then begin
	    //
	    signs_index := 0;
	    for j := 0 to num_sign_bits - 1 do begin
	      //
	      GET_NEXT_BIT();
	      signs_index := sshl(signs_index, 1);
	      inc(signs_index, next_bit);
	      dec(number_of_bits_left);
	    end;
	    //
	    bit := 1 shl (num_sign_bits - 1);
	  end;
	  //
	  for j := 0 to vec_dim - 1 do begin
	    //
	    {*
	    ** This was changed to for fixed point interop
	    ** A scale factor of 22.0 is used to adjust the decoded mlt value.
	    *}
	    decoder_mlt_value := standard_deviation * mlt_quant_centroid[category][k[j]] * NOISE_SCALE_FACTOR;
	    //
	    if (0 <> decoder_mlt_value) then begin
	      //
	      if (0 = (signs_index and bit)) then
		decoder_mlt_value := decoder_mlt_value * -1.0;
	      //
	      if (0 > bit) then
		bit := -1;
	      //
	      bit := sshr(bit, 1);
	    end;
	    //
	    decoder_mlt_ptr^ := decoder_mlt_value;
	    inc(decoder_mlt_ptr);
	  end;
        end
	else begin
	  //
	  ran_out_of_bits_flag := 1;
	  break;
	end;
	//
      end; // for n ...
      //
      //* If ran out of bits during decoding do noise fill for remaining regions. */
      if (1 = ran_out_of_bits_flag) then begin
        //
        for j := region + 1 to number_of_regions - 1 do
          decoder_power_categories[j] := NUM_CATEGORIES - 1;
        //
        category := NUM_CATEGORIES - 1;
        decoder_mlt_ptr := @decoder_mlt_coefs[region * region_size];
      end;
    end;
    //
    if (category = NUM_CATEGORIES - 3) then begin
      //
      decoder_mlt_ptr := @decoder_mlt_coefs[region * region_size];
      n := 0;
      for j := 0 to region_size - 1 do begin
	//
	if (decoder_mlt_ptr^ <> 0) then begin
	  //
	  inc(n);
	  if (Abs(decoder_mlt_ptr^) > 44.0 * standard_deviation) then
	    inc(n, 3);
	end;
	//
	inc(decoder_mlt_ptr);
      end;
      //
      if (n > 19) then n := 19;
      //
      temp1 := noise_fill_factor_cat5[n];
      //
      decoder_mlt_ptr := @decoder_mlt_coefs[region * region_size];
      //
      //*noifillpos = standard_deviation * 0.17678; */
      noifillpos := standard_deviation * temp1;
      noifillneg := -noifillpos;
      //
      //* This assumes region_size = 20 */
      //
      get_rand(random_word);
      //
      for j := 0 to 10 - 1 do begin
	//
	if (decoder_mlt_ptr^ = 0) then begin
	  //
	  temp1 := noifillpos;
	  //
	  if (0 = (random_word and 1)) then temp1 := noifillneg;
	  //
	  decoder_mlt_ptr^ := temp1 * NOISE_SCALE_FACTOR;
	  //
	  random_word := sshr(random_word, 1);
	end;
	//
	inc(decoder_mlt_ptr);
      end;
      //
      get_rand(random_word);
      //
      for j := 0 to 10 - 1 do begin
	//
	if (decoder_mlt_ptr^ = 0) then begin
	  //
	  temp1 := noifillpos;
	  if (0 = (random_word and 1)) then temp1 := noifillneg;
	  //
	  decoder_mlt_ptr^ := temp1 * NOISE_SCALE_FACTOR;
	  //
	  random_word := sshr(random_word, 1);
	end;
	//
	inc(decoder_mlt_ptr);
      end;
    end;
    //
    if (category = NUM_CATEGORIES-2) then begin
      //
      decoder_mlt_ptr := @decoder_mlt_coefs[region * region_size];
      n := 0;
      for j := 0 to region_size - 1 do begin
	//
	if (decoder_mlt_ptr^ <> 0) then
	  inc(n);
	//
	inc(decoder_mlt_ptr);
      end;
      //
      if (n > high(noise_fill_factor_cat6)) then
	n := high(noise_fill_factor_cat6);
      //
      temp1 := noise_fill_factor_cat6[n];
      decoder_mlt_ptr := @decoder_mlt_coefs[region * region_size];
      noifillpos := standard_deviation * temp1;
      noifillneg := -noifillpos;
      //
      //* This assumes region_size = 20 */
      //
      get_rand(random_word);
      //
      for j := 0 to 10 - 1 do begin
	//
	if (decoder_mlt_ptr^ = 0) then begin
	  //
	  temp1 := noifillpos;
	  if (0 = (random_word and 1)) then temp1 := noifillneg;
	  //
	  decoder_mlt_ptr^ := temp1 * NOISE_SCALE_FACTOR;
	  //
	  random_word := sshr(random_word, 1);
	end;
	//
	inc(decoder_mlt_ptr);
      end;
      //
      get_rand(random_word);
      //
      for j := 0 to 10 - 1 do begin
	//
	if (decoder_mlt_ptr^ = 0) then begin
	  //
	  temp1 := noifillpos;
	  if (0 = (random_word and 1)) then temp1 := noifillneg;
	  //
	  decoder_mlt_ptr^ := temp1 * NOISE_SCALE_FACTOR;
	  //
	  random_word := sshr(random_word, 1);
	end;
	//
	inc(decoder_mlt_ptr);
      end;
    end;
    //
    if (category = NUM_CATEGORIES - 1) then begin
      //
      noifillpos := standard_deviation * 0.70711;
      noifillneg := -noifillpos;
      //
      //* This assumes region_size = 20 */
      //
      get_rand(random_word);
      //
      for j := 0 to 10 - 1 do begin
	//
	temp1 := noifillpos;
	if (0 = (random_word and 1)) then temp1 := noifillneg;
	//
	decoder_mlt_ptr^ := temp1 * NOISE_SCALE_FACTOR;
	inc(decoder_mlt_ptr);
	//
	random_word := sshr(random_word, 1);
      end;
      //
      get_rand(random_word);
      //
      for j := 0 to 10 - 1 do begin
	//
	temp1 := noifillpos;
	if (0 = (random_word and 1)) then temp1 := noifillneg;
	//
	decoder_mlt_ptr^ := temp1 * NOISE_SCALE_FACTOR;
	inc(decoder_mlt_ptr);
	//
	random_word := sshr(random_word, 1);
      end;
    end;
    //
  end; // for region ...
  //
  if (0 <> ran_out_of_bits_flag) then
    number_of_bits_left := -1;
end;





//=======================================   ====================================
//======================================= ENCODE ====================================
//=======================================   ====================================



{ unaG7221Encoder }


{*****************************************************************
******************************************************************
**
**   G.722.1 Annex B - G.722.1 Floating point implementation
**   > Software Release 2.1 (2008-06)
**
**	Filename : samples_to_rmlt_coefs.c
**
**   © 2000 PictureTel Coporation
**          Andover, MA, USA
**
**	    All rights reserved.
**
******************************************************************
*****************************************************************}

{************************************************************************************
 Include files
*************************************************************************************}
//#include <stdio.h>
//#include <math.h>
//#include "defs.h"

//#define ABS(a)  (a>0?a:-a)

{***************************************************************************
 Procedure/Function:  samples_to_rmlt_coefs

 Syntax:     void samples_to_rmlt_coefs(new_samples,
										coefs,
										dct_size)
				float *new_samples;
				float *coefs;
				int dct_size;


 Description: samples_to_rmlt_coefs 	Convert Samples to Reversed MLT (Modulated Lapped
										Transform) Coefficients

     The "Reversed MLT" is an overlapped block transform which uses even symmetry
 on the left, odd symmetry on the right and a Type IV DCT as the block transform.
 It is thus similar to a MLT which uses odd symmetry on the left, even symmetry
 on the right and a Type IV DST as the block transform.  In fact, it is equivalent
 to reversing the order of the samples, performing an MLT and then negating all
 the even-numbered coefficients.


 Design Notes:

***************************************************************************}
procedure unaG7221Encoder.samples_to_rmlt_coefs(
  new_samples: pFloat;
  coefs: pFloat;
  dct_size: int32);
var
  //extern void dct_type_iv(float *, float *, long);
  index, vals_left: int32;
  sum: float;
  angle: double;
  windowed_data: tmax_dct_sizef;
  new_ptr, old_ptr, sam_low, sam_high: pFloat;
  win_low, win_high: pFloat;
  dst_ptr: pFloat;
  half_dct_size: int32;
begin
  half_dct_size := dct_size shr 1;
  //
  //*++++++++++++++++++++++++++++++++++++++*/
  //* Set up some data the first time here */
  //*++++++++++++++++++++++++++++++++++++++*/
  //
  if (0 = here_before4) then begin
    //
    for index := 0 to dct_size - 1 do begin
      //
      angle := (PI / 2.0) * (index + 0.5) / dct_size;
      window2[index] := sin(angle);
    end;
    //
    for index := 0 to dct_size - 1 do
      old_samples2[index] := 0.0;
    //
    here_before4 := 1;
  end;
  //
  //*++++++++++++++++++++++++++++++++++++++++++++*/
  //* Get the first half of the windowed samples */
  //*++++++++++++++++++++++++++++++++++++++++++++*/
  //
  dst_ptr  := pFloat(@windowed_data);
  win_high := pFloat(@window2[half_dct_size]);
  win_low  := win_high;
  //
  sam_high := pFloat(@old_samples2[half_dct_size]);
  sam_low  := sam_high;
  for vals_left := half_dct_size downto 0 + 1 do begin
    //
    dec(win_low);
    dec(sam_low);
    sum := win_low^ * sam_low^;
    //
    sum := sum + win_high^ * sam_high^;
    inc(win_high);
    inc(sam_high);
    //
    dst_ptr^ := sum;
    inc(dst_ptr);
  end;
  //
  //*+++++++++++++++++++++++++++++++++++++++++++++*/
  //* Get the second half of the windowed samples */
  //*+++++++++++++++++++++++++++++++++++++++++++++*/
  //
  sam_low  := new_samples;
  sam_high := @pFloatArray(new_samples)[dct_size];
  for vals_left := half_dct_size downto 0 + 1 do begin
    //
    dec(win_high);
    sum := win_high^ * sam_low^;
    inc(sam_low);
    //
    dec(sam_high);
    sum := sum - win_low^ * sam_high^;
    inc(win_low);
    //
    dst_ptr^ := sum;
    inc(dst_ptr);
  end;
  //
  //*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
  //* Save the new samples for next time, when they will be the old samples */
  //*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
  //
  new_ptr := new_samples;
  old_ptr := pFloat(@old_samples2);
  for vals_left := dct_size downto 0 + 1 do begin
    //
    old_ptr^ := new_ptr^;
    inc(old_ptr);
    inc(new_ptr);
  end;
  //
  //*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
  //* Perform a Type IV DCT on the windowed data to get the coefficients */
  //*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
  dct.dct_type_iv(pFloat(@windowed_data), coefs, dct_size);
end;

// --  --
function unaG7221Encoder.encode(inFrame: pInt16; inSamples: int): int;
var
  i: int32;
begin
  result := 0;
  //
  while (inSamples >= frameSize) do begin
    //
    for i := 0 to framesize - 1 do begin
      //
      float_new_samples[i] := inFrame^;
      inc(inFrame);
      dec(inSamples);
    end;
    //
    inc(result);
    //
    //* Convert input samples to rmlt coefs   */
    samples_to_rmlt_coefs(pFloat(@float_new_samples), pFloat(@mlt_coefs), framesize);
    //
    // This was added to for fixed point interop
    for i := 0 to framesize - 1 do
      mlt_coefs[i] := mlt_coefs[i] / NOISE_SCALE_FACTOR;
    //
    //* Encode the mlt coefs  */
    encoder(14, //number_of_regions,
	    number_of_bits_per_frame,
	    mlt_coefs,
	    out_words);
    //
    //* write the output bitstream to the output file */
    notify(@out_words, number_of_16bit_words_per_frame shl 1);
  end;
end;


{*****************************************************************
******************************************************************
**
**   G.722.1 Annex B - G.722.1 Floating point implementation
**   > Software Release 2.1 (2008-06)
**
**	Filename : encoder.c
**
**   © 2000 PictureTel Coporation
**          Andover, MA, USA
**
**	    All rights reserved.
**
**************************************************************************}

{***************************************************************************
  Filename:   encoder.c
  Original Author:
  Creation Date:
  Purpose:         Contains files used to implement
		   the G.722.1 encoder
***************************************************************************}

{***************************************************************************
 Procedure/Function:  encoder

 Syntax:      void encoder( number_of_regions,
							number_of_available_bits,
							mlt_coefs,
							out_words)
							int number_of_regions;
							int number_of_available_bits;
							float mlt_coefs[MAX_DCT_SIZE];
							short int out_words[MAX_BITS_PER_FRAME/16];

	      inputs:   number_of_regions
						number_of_available_bits
			mlt_coefs[MAX_DCT_SIZE]

	      outputs:  out_words[MAX_BITS_PER_FRAME/16]


 Description:  Encodes the mlt coefs into out_words using the G.722.1 algorithm

***************************************************************************}
procedure unaG7221Encoder.encoder(
     number_of_regions: int32;
     number_of_available_bits: int32;
     const mlt_coefs: tmax_dct_sizef;
     out out_words: tmax_frame);
var
//  extern void categorize(int, int, int[], int[], int[]);
  number_of_bits_per_frame,
  number_of_envelope_bits,
  rate_control,
  region: int32;
  absolute_region_power_index: tmax_regions;
  power_categories: tmax_regions;
  category_balances: tmax_rate_control;
  //
  drp_num_bits: tmax_regionsP1;
  drp_code_bits: tmax_regionsP1;
  //
  drp_num_bitsp: tmax_regions absolute drp_num_bits;
  drp_code_bitsp: tmax_regions absolute drp_code_bits;
  //
  region_mlt_bit_counts: tmax_regions;
  region_mlt_bits: tmax_regions4;
  //
  out_word_index,
  j: int32;
  out_word: uint32;
  region_bit_count,
  current_word_bits_left: int32;
  slice: uint16;
  //
  out_word_bits_free: int32;
  //
  in_word_ptr: pUInt32;
  current_word: uint32;
begin
  if (number_of_regions <= 14) then begin
    //
    num_rate_control_bits := 4;
    num_rate_control_possibilities := 16;
  end;
  //
  number_of_bits_per_frame := number_of_available_bits;
  //
  //* Estimate power envelope. */
  //
  number_of_envelope_bits := compute_region_powers(number_of_regions,
						  mlt_coefs,
						  drp_num_bitsp,
						  drp_code_bitsp,
						  absolute_region_power_index);
  //
  dec(number_of_available_bits, number_of_envelope_bits);
  dec(number_of_available_bits, num_rate_control_bits);
  //
  mtl.categorize(number_of_regions, num_rate_control_possibilities,
	     number_of_available_bits,
	     absolute_region_power_index,
	     power_categories,
	     category_balances);
  //
  {* Adjust absolute_region_category_index[] for mag_shift.
     This assumes that REGION_POWER_STEPSIZE_DB is defined
     to be exactly 3.010299957 or 20.0 times log base 10
     of square root of 2. *}
  //
  for region := 0 to number_of_regions - 1 do
    inc(absolute_region_power_index[region], REGION_POWER_TABLE_NUM_NEGATIVES);
  //
  for region := 0 to number_of_regions - 1 do
    region_mlt_bit_counts[region] := 0;
  //
  vector_quantize_mlts(number_of_regions,
		       number_of_available_bits,
		       mlt_coefs,
		       absolute_region_power_index,
		       power_categories,
		       category_balances,
		       rate_control,
		       region_mlt_bit_counts,
		       region_mlt_bits);

  //{
  out_word_index := 0;
  out_word := 0;
  out_word_bits_free := 16;
  //
  //* First set up the rate control bits to look like one more set of region power bits. */
  //
  drp_num_bits[number_of_regions] := num_rate_control_bits;
  drp_code_bits[number_of_regions] := rate_control;
  //
  //* These code bits are right justified. */
  //
  for region := 0 to number_of_regions do begin
    //
    current_word_bits_left := drp_num_bits[region];
    current_word := drp_code_bits[region];
    //
    j := current_word_bits_left - out_word_bits_free;
    if (j >= 0) then begin
      //
      inc(out_word, sshr(current_word, j));
      out_words[out_word_index] := out_word;
      inc(out_word_index);
      out_word_bits_free := 16;
      out_word := (current_word shl (16 - j)) and $FFFF;
      dec(out_word_bits_free, j);
    end
    else begin
      //
      inc(out_word, current_word shl (-j));
      dec(out_word_bits_free, current_word_bits_left);
    end;
  end;
  //
  //* These code bits are left justified. */
  for region := 0 to number_of_regions - 1 do begin
    //
    if ( ((16 * out_word_index) >= number_of_bits_per_frame) ) then
      break;
    //
    in_word_ptr := @region_mlt_bits[4 * region];
    region_bit_count := region_mlt_bit_counts[region];
    current_word_bits_left := Math.Min(32, region_bit_count);
    current_word := in_word_ptr^;
    inc(in_word_ptr);
    //
    while ((region_bit_count > 0) and ((16 * out_word_index) < number_of_bits_per_frame)) do begin
      //
      if (current_word_bits_left >= out_word_bits_free) then begin
	//
	slice := current_word shr (32 - out_word_bits_free);
	inc(out_word, slice);
	current_word := current_word shl out_word_bits_free;
	dec(current_word_bits_left, out_word_bits_free);
	//
	out_words[out_word_index] := out_word;
	inc(out_word_index);
	//
	out_word := 0;
	out_word_bits_free := 16;
      end
      else begin
	//
	slice := current_word shr (32 - current_word_bits_left);
	inc(out_word, slice shl (out_word_bits_free - current_word_bits_left));
	dec(out_word_bits_free, current_word_bits_left);
	current_word_bits_left := 0;
      end;
      //
      if (0 = current_word_bits_left) then begin
	//
	current_word := in_word_ptr^;
	inc(in_word_ptr);
	//
	dec(region_bit_count, 32);
	current_word_bits_left := Math.Min(32, region_bit_count);
      end;
    end;
  end;
  //
  //* Fill out with 1's. */
  //
  while ((16 * out_word_index) < number_of_bits_per_frame) do begin
    //
    current_word := $0000ffff;
    slice := current_word shr (16 - out_word_bits_free);
    inc(out_word, slice);
    out_words[out_word_index] := out_word;
    inc(out_word_index);
    out_word := 0;
    out_word_bits_free := 16;
  end;
  //}
end;

// -- --
function unaG7221Encoder.process(ptr: pointer; len: uint): int;
begin
  result := encode(pInt16(ptr), int(len shr 1));     // 16 bit samples
end;

// -- --
function unaG7221Encoder.chunkSize(): uint;
begin
  result := frameSize shl 1;    // 16 bits samples
end;


{***************************************************************************
 Procedure/Function:  compute_region_powers

 Syntax:   int compute_region_powers( number_of_regions,
									  mlt_coefs,
									  drp_num_bits,
									  drp_code_bits,
									  absolute_region_power_index)
									 int number_of_regions;
									 float mlt_coefs[MAX_DCT_SIZE];
									 int drp_num_bits[MAX_NUM_REGIONS];
									 int drp_code_bits[MAX_NUM_REGIONS];
									 int absolute_region_power_index[MAX_NUM_REGIONS];

 Description:   Computes the power for each of the regions

***************************************************************************}
function unaG7221Encoder.compute_region_powers(
     number_of_regions: int32;
     mlt_coefs: tmax_dct_sizef;
     out drp_num_bits: tmax_regions;
     out drp_code_bits: tmax_regions;
     out absolute_region_power_index: tmax_regions): int32;
var
  input_ptr: pFloat;
  iterations: int32;
  ftemp0, ftemp1: float;
  index, index_min, index_max: int32;
  region, j: int32;
  differential_region_power_index: tmax_regions;
  number_of_bits: int32;
begin
  input_ptr := pFloat(@mlt_coefs);
  for region := 0 to number_of_regions - 1 do begin
    //
    ftemp0 := 0.0;
    for j := 0 to region_size - 1 do begin
      //
      ftemp1 := input_ptr^;
      inc(input_ptr);
      //
      ftemp0 := ftemp0 + ftemp1 * ftemp1;
    end;
    //
    ftemp0 := ftemp0 * region_size_inverse;
    //
    index_min := 0;
    index_max := REGION_POWER_TABLE_SIZE;
    for iterations := 0 to 6 - 1 do begin
      //
      index := sshr((index_min + index_max), 1);
      if (ftemp0 < mtl.region_power_table_boundary[index - 1]) then
	index_max := index
      else
	index_min := index;
    end;
    //
    absolute_region_power_index[region] := index_min - REGION_POWER_TABLE_NUM_NEGATIVES;
  end;
  //
  //* Before we differentially encode the quantized region powers, adjust upward the
  //   valleys to make sure all the peaks can be accurately represented. */
  //
  for region := number_of_regions - 2 downto 0 do begin
    //
    if (absolute_region_power_index[region] < absolute_region_power_index[region + 1] - DRP_DIFF_MAX) then
      absolute_region_power_index[region] := absolute_region_power_index[region + 1] - DRP_DIFF_MAX;
  end;
  //
  {* The MLT is currently scaled too low by the factor
   ENCODER_SCALE_FACTOR(=18318)/32768 * (1./sqrt(160).
   This is the ninth power of 1 over the square root of 2.
   So later we will add ESF_ADJUSTMENT_TO_RMS_INDEX (now 9)
   to drp_code_bits[0]. *}
  //
  //* drp_code_bits[0] can range from 1 to 31. 0 will be used only as an escape sequence. */
  //
  if (absolute_region_power_index[0] < 1 - ESF_ADJUSTMENT_TO_RMS_INDEX) then
    absolute_region_power_index[0] := 1-ESF_ADJUSTMENT_TO_RMS_INDEX;
  if (absolute_region_power_index[0] > 31 - ESF_ADJUSTMENT_TO_RMS_INDEX) then
    absolute_region_power_index[0] := 31-ESF_ADJUSTMENT_TO_RMS_INDEX;
  //
  differential_region_power_index[0] := absolute_region_power_index[0];
  number_of_bits := 5;
  drp_num_bits[0] := 5;
  drp_code_bits[0] := absolute_region_power_index[0] + ESF_ADJUSTMENT_TO_RMS_INDEX;
  //
  //* Lower limit the absolute region power indices to -8 and upper limit them to 31. Such extremes
  //  may be mathematically impossible anyway.*/
  //
  for region := 1 to number_of_regions - 1 do begin
    //
    if (absolute_region_power_index[region] < -8 - ESF_ADJUSTMENT_TO_RMS_INDEX) then
      absolute_region_power_index[region] := -8 - ESF_ADJUSTMENT_TO_RMS_INDEX;
    //
    if (absolute_region_power_index[region] > 31 - ESF_ADJUSTMENT_TO_RMS_INDEX) then
      absolute_region_power_index[region] := 31 - ESF_ADJUSTMENT_TO_RMS_INDEX;
  end;
  //
  for region := 1 to number_of_regions - 1 do begin
    //
    j := absolute_region_power_index[region] - absolute_region_power_index[region - 1];
    if (j < DRP_DIFF_MIN) then
      j := DRP_DIFF_MIN;
    //
    dec(j, DRP_DIFF_MIN);
    differential_region_power_index[region] := j;
    absolute_region_power_index[region] := absolute_region_power_index[region-1] + differential_region_power_index[region] + DRP_DIFF_MIN;
    //
    inc(number_of_bits, differential_region_power_bits[region][j]);
    drp_num_bits[region] := differential_region_power_bits[region][j];
    drp_code_bits[region] := differential_region_power_codes[region][j];
  end;
  //
  result := number_of_bits;
end;

{***************************************************************************
 Procedure/Function:  vector_quantize_mlts

 Syntax:    void vector_quantize_mlts(number_of_regions,
			  number_of_available_bits,
			  mlt_coefs,
			  absolute_region_power_index,
			  power_categories,
			  category_balances,
			  p_rate_control,
			  region_mlt_bit_counts,
			  region_mlt_bits)

     int number_of_regions;
     int number_of_available_bits;
     float mlt_coefs[MAX_DCT_SIZE];
     int absolute_region_power_index[MAX_NUM_REGIONS];
     int power_categories[MAX_NUM_REGIONS];
     int category_balances[MAX_NUM_RATE_CONTROL_POSSIBILITIES-1];
     int *p_rate_control;
     int region_mlt_bit_counts[MAX_NUM_REGIONS];
     int region_mlt_bits[4*MAX_NUM_REGIONS];

 Description:

***************************************************************************}
procedure unaG7221Encoder.vector_quantize_mlts(
     number_of_regions: int32;
     number_of_available_bits: int32;
     const mlt_coefs: tmax_dct_sizef;
     const absolute_region_power_index: tmax_regions;
     var power_categories: tmax_regions;
     const category_balances: tmax_rate_control;
     out p_rate_control: int32;
     out region_mlt_bit_counts: tmax_regions;
     const region_mlt_bits: tmax_regions4);
var
  raw_mlt_ptr: pFloat;
  region: int32;
  category: int32;
  total_mlt_bits: int32;
begin
  total_mlt_bits := 0;
  //
  //* Start in the middle of the rate control range. */
  //
  p_rate_control := 0;
  while (p_rate_control < (num_rate_control_possibilities shr 1) - 1) do begin
    //
    region := category_balances[p_rate_control];
    inc(power_categories[region]);
    //
    inc(p_rate_control);
  end;
  //
  for region := 0 to number_of_regions - 1 do begin
    //
    category := power_categories[region];
    raw_mlt_ptr := @mlt_coefs[region * region_size];
    //
    if (category < NUM_CATEGORIES - 1) then begin
      //
      region_mlt_bit_counts[region] :=
	vector_huffman(category, absolute_region_power_index[region], raw_mlt_ptr, @region_mlt_bits[4 * region]);
    end
    else
      region_mlt_bit_counts[region] := 0;
    //
    inc(total_mlt_bits, region_mlt_bit_counts[region]);
  end;
  //
  //* If too few bits... */
  //
  while ((total_mlt_bits < number_of_available_bits) and (p_rate_control > 0)) do begin
    //
    dec(p_rate_control);
    region := category_balances[p_rate_control];
    dec(power_categories[region]);
    dec(total_mlt_bits, region_mlt_bit_counts[region]);
    //
    category := power_categories[region];
    raw_mlt_ptr := @mlt_coefs[region * region_size];
    //
    if (category < NUM_CATEGORIES - 1) then begin
      //
      region_mlt_bit_counts[region] :=
	  vector_huffman(category, absolute_region_power_index[region], raw_mlt_ptr, @region_mlt_bits[4 * region]);
    end
    else
      region_mlt_bit_counts[region] := 0;
    //
    inc(total_mlt_bits, region_mlt_bit_counts[region]);
  end;
  //
  //* If too many bits... */
  //
  while ((total_mlt_bits > number_of_available_bits) and (p_rate_control < num_rate_control_possibilities - 1)) do begin
    //
    region := category_balances[p_rate_control];
    inc(power_categories[region]);
    //
    dec(total_mlt_bits, region_mlt_bit_counts[region]);
    //
    category := power_categories[region];
    raw_mlt_ptr := @mlt_coefs[region * region_size];
    if (category < NUM_CATEGORIES - 1) then begin
      //
      region_mlt_bit_counts[region] :=
	  vector_huffman(category, absolute_region_power_index[region], raw_mlt_ptr, @region_mlt_bits[4 * region]);
    end
    else
      region_mlt_bit_counts[region] := 0;
    //
    inc(total_mlt_bits, region_mlt_bit_counts[region]);
    inc(p_rate_control);
  end;
end;


{***************************************************************************
 Procedure/Function:  vector_huffman

 Syntax:    int vector_huffman(category,
							   power_index,
							   raw_mlt_ptr,
							   word_ptr)

							 int category;
							 int power_index;
							 float *raw_mlt_ptr;
							 int *word_ptr;

	     inputs:     int  category
			 int  power_index
			 float  *raw_mlt_ptr

	     outputs:    int    *word_ptr


 Description:  Huffman encoding for each region based on category and power_index

***************************************************************************}
function unaG7221Encoder.vector_huffman(
     category: int32;
     power_index: int32;
     raw_mlt_ptr: pFloat;
     word_ptr: pUInt32): int32;
var
  inv_of_step_size_times_std_dev: float;
  j, n,
  k,
  number_of_region_bits,
  number_of_non_zero,
  vec_dim,
  num_vecs,
  kmax, kmax_plus_one,
  index: int32;
  signs_index: uint;
  //
  bitcount_table_ptr: pInt32;
  code_table_ptr: pInt32;
  //
  code_bits,
  number_of_code_bits,
  current_word,
  current_word_bits_free: uint32;
begin
  vec_dim := vector_dimension[category];
  num_vecs := number_of_vectors[category];
  kmax := max_bin[category];
  kmax_plus_one := kmax + 1;
  //
  current_word := 0;
  current_word_bits_free := 32;
  //
  number_of_region_bits := 0;
  //
  bitcount_table_ptr := table_of_bitcount_tables[category];
  code_table_ptr := table_of_code_tables[category];
  //
  inv_of_step_size_times_std_dev :=
    mtl.step_size_inverse_table[category] * mtl.standard_deviation_inverse_table[power_index];
  //
  for n := 0 to num_vecs - 1 do begin
    //
    index := 0;
    signs_index := 0;
    number_of_non_zero := 0;
    for j := 0 to vec_dim - 1 do begin
      //
      k := trunc(Abs(raw_mlt_ptr^) * inv_of_step_size_times_std_dev + dead_zone[category]);
      if (0 <> k) then begin
	//
	inc(number_of_non_zero);
	signs_index := sshl(signs_index, 1);
	if (raw_mlt_ptr^ > 0) then
	  inc(signs_index);
	//
	if (k > kmax) then
	  k := kmax;
      end;
      //
      index := index * (kmax_plus_one) + k;
      inc(raw_mlt_ptr);
    end;
    //
    code_bits := pInt32Array(code_table_ptr)[index];
    number_of_code_bits := pInt32Array(bitcount_table_ptr)[index] + number_of_non_zero;
    inc(number_of_region_bits, number_of_code_bits);
    //
    code_bits := (code_bits shl number_of_non_zero) + signs_index;
    //
    //* msb of codebits is transmitted first. */
    //
    j := int32(current_word_bits_free) - int32(number_of_code_bits);
    if (j >= 0) then begin
      //
      inc(current_word, code_bits shl j);
      current_word_bits_free := j;
    end
    else begin
      //
      j := -j;
      inc(current_word, code_bits shr j);
      word_ptr^ := current_word;
      inc(word_ptr);
      //
      current_word_bits_free := 32 - j;
      current_word := code_bits shl current_word_bits_free;
    end;
    //
  end; // for n ...
  //
  word_ptr^ := current_word;
  //inc(word_ptr);
  //
  result := number_of_region_bits;
end;


end.

